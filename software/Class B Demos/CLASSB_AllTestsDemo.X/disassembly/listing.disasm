Disassembly Listing for CLASSB_AllTestsDemo
Generated From:
C:/Users/C13819/Documents/Class_B/Class B/ClassB PIC12-16 Library Version 3.00/Class B Demos/CLASSB_AllTestsDemo.X/dist/default/debug/CLASSB_AllTestsDemo.X.debug.cof
May 1, 2014 3:14:22 PM

---  C:/Users/C13819/Documents/Class_B/Class B/ClassB PIC12-16 Library Version 3.00/Microchip/Class B/CLASSB_RAMMarchCTest.c
1:             /**********************************************************************
2:             * © 2013 Microchip Technology Inc.
3:             *
4:             * Project Name:     Class B Library
5:             * FileName:         CLASSB_RAMMarchCTest.c
6:             * Dependencies:     CLASSB_RAMMarchCTest.h
7:             * Processor:        PIC16F1xxx
8:             * Compiler:         XC8
9:             * IDE:              MPLAB® IDE or MPLAB® X
10:            * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
11:            * Description:     This file contains functions to RAM with MarchC Test.
12:            *
13:            **************************************************************************
14:             * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER: You may use this software, and
15:             * any derivatives created by any person or entity by or on your behalf,
16:             * exclusively with Microchip's products in accordance with applicable
17:             * software license terms and conditions, a copy of which is provided for
18:             * your referencein accompanying documentation. Microchip and its licensors
19:             * retain all ownership and intellectual property rights in the
20:             * accompanying software and in all derivatives hereto.
21:             *
22:             * This software and any accompanying information is for suggestion only.
23:             * It does not modify Microchip's standard warranty for its products. You
24:             * agree that you are solely responsible for testing the software and
25:             * determining its suitability. Microchip has no obligation to modify,
26:             * test, certify, or support the software.
27:             *
28:             * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:             * EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED
30:             * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:             * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE, ITS INTERACTION WITH
32:             * MICROCHIP'S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
33:             * APPLICATION.
34:             *
35:             * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY,
36:             * TORT (INCLUDING NEGLIGENCE OR BREACH OF STATUTORY DUTY), STRICT
37:             * LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT,
38:             * SPECIAL, PUNITIVE, EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE,
39:             * FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE SOFTWARE,
40:             * HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY
41:             * OR THE DAMAGES ARE FORESEEABLE. TO THE FULLEST EXTENT ALLOWABLE BY LAW,
42:             * MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
43:             * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID
44:             * DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
45:             *
46:             * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
47:             * THESE TERMS.
48:             *************************************************************************
49:            *
50:            * REVISION HISTORY:
51:            *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
52:            * Author            Date      Comments on this revision
53:            *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
54:            * CT                09/15/2008  First release of source file
55:            * Mike Cahill       11/11/2010	Updated for HI-TECH v9.80
56:            * MVL               02/22/2011	Modified for HI-TECH v9.81
57:            * EA                02/18/2012	Made corrections to March C Minus routine
58:            * Corey Simoncic    04/19/2013  Updated for XC-8
59:            *
60:            * Version       3.00
61:            *
62:            *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
63:            * ADDITIONAL NOTES:
64:            *
65:            **********************************************************************/
66:            
67:            #include "CLASSB_RAMMarchCTest.h"
68:            
69:            #ifndef MARCH_VARS
70:            #define MARCH_VARS
71:            unsigned char* CLASSB_MarchstartAddress @ 0x20;
72:            unsigned char* CLASSB_MarchbufferAddress @ 0x22;
73:            unsigned char* CLASSB_MARCHtempAddress @ 0x24;
74:            unsigned char CLASSB_MarchLength @ 0x26 = 0;
75:            #endif
76:            
77:            /******************************************************************************
78:            * Description  : This function implements the March C or March C Minus test.
79:            * It is a complete and irredundant test capable of detecting stuck-at faults,
80:            * addressing faults, transition faults, and coupling faults. This test is of complexity
81:            * 11n (Where n is the number of bits), 10n for March C Minus test.
82:            *
83:            * This test is a destructive test!!! CLASSB_MarchbufferAddress is used as a an array to save user
84:            * memory during the test!
85:            *
86:            * Input:
87:            *     CLASSB_MarchstartAddress     :  pointer to an array declared in user memory for test
88:            *     CLASSB_MarchLength            :  value indicating the number of bytes to test
89:            *     CLASSB_MarchbufferAddress    :  pointer to location in memory where array will be stored during test
90:            *     MARCHCMINUS                   :  designates the test is a March C Minus test.
91:            * Return Values:
92:            *     CLASSB_TEST_PASS 	:  return value = 0
93:            *     CLASSB_TEST_FAIL 	:  return value = 1
94:            *
95:            ******************************************************************************/
96:            CLASSBRESULT CLASSB_RAMMarchCTest()
97:            {
98:                volatile unsigned char testResult;
99:            
100:           /******************************************************************************
101:            * Save memory for test in a known location designated by *CLASSB_MarchbufferAddress
102:            ******************************************************************************/
103:           //    if (CLASSB_MarchbufferAddress != NULL)
104:           ////    memcpy(CLASSB_MarchbufferAddress, CLASSB_MarchstartAddress, CLASSB_MarchLength);
105:           //    {
106:           //        if (CLASSB_MarchstartAddress < (char*)0x27)
107:           //        {
108:           //            CLASSB_MarchLength -= (0x28 - (char)CLASSB_MarchstartAddress);
109:           //            CLASSB_MarchstartAddress = (char*)0x27;
110:           //        }
111:           //        CLASSB_MARCHtempAddress = CLASSB_MarchstartAddress;
112:           //        for (WREG_SHAD = CLASSB_MarchLength; WREG_SHAD != 0; WREG_SHAD--)
113:           //        {
114:           //            *CLASSB_MarchbufferAddress++ = *CLASSB_MARCHtempAddress++;
115:           //        }
116:           //    }
117:           
118:           /******************************************************************************
119:            * Run March C Test on global RAM used by March C test.
120:            ******************************************************************************/
121:               if (CLASSB_MarchstartAddress < (char*)0x27)
041A  3000     MOVLW 0x0
041B  0221     SUBWF 0x21, W
041C  3027     MOVLW 0x27
041D  1903     BTFSC STATUS, 0x2
041E  0220     SUBWF CLASSB_MarchstartAddress, W
041F  1803     BTFSC STATUS, 0x0
0420  2C31     GOTO 0x431
122:               {
123:                   testResult = MarchCGlobalTest();
0421  2578     CALL 0x578
0422  3180     MOVLP 0x0
0423  0020     MOVLB 0x0
0424  00AE     MOVWF d
124:                   if (testResult)
0425  082E     MOVF d, W
0426  1D03     BTFSS STATUS, 0x2
125:                   {
126:           //            MarchCFailure();
127:                       return CLASSB_TEST_FAIL;
0427  3401     RETLW 0x1
128:                   }
129:                   CLASSB_MarchLength -= (0x28 - (char)CLASSB_MarchstartAddress);
0428  3028     MOVLW 0x28
0429  00AD     MOVWF dataSequence
042A  0820     MOVF CLASSB_MarchstartAddress, W
042B  02AD     SUBWF dataSequence, F
042C  082D     MOVF dataSequence, W
042D  02A6     SUBWF CLASSB_MarchLength, F
130:                   CLASSB_MarchstartAddress = (char*)0x27;
042E  3027     MOVLW 0x27
042F  00A0     MOVWF CLASSB_MarchstartAddress
0430  01A1     CLRF 0x21
131:               }
132:           
133:           /******************************************************************************
134:            * Save memory for test in a known location designated by *CLASSB_MarchbufferAddress
135:            * The ClassB_March... variables will not be saved.
136:            ******************************************************************************/
137:               if (CLASSB_MarchbufferAddress != NULL)
0431  0823     MOVF 0x23, W
0432  0422     IORWF CLASSB_MarchbufferAddress, W
0433  1903     BTFSC STATUS, 0x2
0434  2C55     GOTO 0x455
138:               {
139:                   CLASSB_MARCHtempAddress = CLASSB_MarchstartAddress;
0435  0821     MOVF 0x21, W
0436  00A5     MOVWF 0x25
0437  0820     MOVF CLASSB_MarchstartAddress, W
0438  00A4     MOVWF CLASSB_MARCHtempAddress
140:                   for (WREG_SHAD = CLASSB_MarchLength; WREG_SHAD != 0; WREG_SHAD--)
0439  0826     MOVF CLASSB_MarchLength, W
043A  003F     MOVLB 0x1F
043B  00E5     MOVWF InterruptsUser
043C  0865     MOVF InterruptsUser, W
043D  1903     BTFSC STATUS, 0x2
043E  2C55     GOTO 0x455
0452  003F     MOVLB 0x1F
0453  03E5     DECF InterruptsUser, F
0454  2C3C     GOTO 0x43C
141:                   {
142:                       *CLASSB_MarchbufferAddress++ = *CLASSB_MARCHtempAddress++;
043F  0020     MOVLB 0x0
0440  0824     MOVF CLASSB_MARCHtempAddress, W
0441  0086     MOVWF FSR1L
0442  0825     MOVF 0x25, W
0443  0087     MOVWF FSR1H
0444  0801     MOVF INDF1, W
0445  00AD     MOVWF dataSequence
0446  0822     MOVF CLASSB_MarchbufferAddress, W
0447  0086     MOVWF FSR1L
0448  0823     MOVF 0x23, W
0449  0087     MOVWF FSR1H
044A  082D     MOVF dataSequence, W
044B  0081     MOVWF INDF1
044C  0AA4     INCF CLASSB_MARCHtempAddress, F
044D  1903     BTFSC STATUS, 0x2
044E  0AA5     INCF 0x25, F
044F  0AA2     INCF CLASSB_MarchbufferAddress, F
0450  1903     BTFSC STATUS, 0x2
0451  0AA3     INCF 0x23, F
143:                   }
144:               }
145:               
146:           /******************************************************************************
147:            * Wr0 - write zero to all memory for test
148:            ******************************************************************************/
149:               CLASSB_MARCHtempAddress = CLASSB_MarchstartAddress;
0455  0020     MOVLB 0x0
0456  0821     MOVF 0x21, W
0457  00A5     MOVWF 0x25
0458  0820     MOVF CLASSB_MarchstartAddress, W
0459  00A4     MOVWF CLASSB_MARCHtempAddress
150:               for (WREG_SHAD=0; WREG_SHAD<CLASSB_MarchLength; WREG_SHAD++)
045A  003F     MOVLB 0x1F
045B  01E5     CLRF InterruptsUser
045C  0020     MOVLB 0x0
045D  0826     MOVF CLASSB_MarchLength, W
045E  003F     MOVLB 0x1F
045F  0265     SUBWF InterruptsUser, W
0460  1803     BTFSC STATUS, 0x0
0461  2C6E     GOTO 0x46E
046B  003F     MOVLB 0x1F
046C  0AE5     INCF InterruptsUser, F
046D  2C5C     GOTO 0x45C
151:               {
152:                   *CLASSB_MarchstartAddress=0x00;
0462  0020     MOVLB 0x0
0463  0820     MOVF CLASSB_MarchstartAddress, W
0464  0086     MOVWF FSR1L
0465  0821     MOVF 0x21, W
0466  0087     MOVWF FSR1H
0467  0181     CLRF INDF1
153:                   CLASSB_MarchstartAddress++;
0468  0AA0     INCF CLASSB_MarchstartAddress, F
0469  1903     BTFSC STATUS, 0x2
046A  0AA1     INCF 0x21, F
154:               }
155:           
156:               FSR1L_SHAD = 0;
046E  01EA     CLRF Timer1User
157:           
158:           /******************************************************************************
159:            * Rd0Wr1 - read zero, write one - ascending
160:            ******************************************************************************/
161:               CLASSB_MarchstartAddress = CLASSB_MARCHtempAddress;
046F  0020     MOVLB 0x0
0470  0825     MOVF 0x25, W
0471  00A1     MOVWF 0x21
0472  0824     MOVF CLASSB_MARCHtempAddress, W
0473  00A0     MOVWF CLASSB_MarchstartAddress
162:               for (WREG_SHAD=0; WREG_SHAD<CLASSB_MarchLength; WREG_SHAD++)
0474  003F     MOVLB 0x1F
0475  01E5     CLRF InterruptsUser
0476  0020     MOVLB 0x0
0477  0826     MOVF CLASSB_MarchLength, W
0478  003F     MOVLB 0x1F
0479  0265     SUBWF InterruptsUser, W
047A  1803     BTFSC STATUS, 0x0
047B  2C9D     GOTO 0x49D
049A  003F     MOVLB 0x1F
049B  0AE5     INCF InterruptsUser, F
049C  2C76     GOTO 0x476
163:               {
164:                   FSR0H_SHAD = 0x00;
047C  01E9     CLRF Timer1GateUser
165:                   for (FSR0L_SHAD=0; FSR0L_SHAD<8; FSR0L_SHAD++)
047D  01E8     CLRF PIR1User
047E  3008     MOVLW 0x8
047F  0268     SUBWF PIR1User, W
0480  1803     BTFSC STATUS, 0x0
0481  2C96     GOTO 0x496
0494  0AE8     INCF PIR1User, F
0495  2C7E     GOTO 0x47E
166:                   {
167:                       #asm
168:                       MOVLB   0x00
0482  0020     MOVLB 0x0
169:                       MOVF    BANKMASK(_CLASSB_MarchstartAddress), W
0483  0820     MOVF CLASSB_MarchstartAddress, W
170:                       MOVWF   FSR1L
0484  0086     MOVWF FSR1L
171:                       MOVF    INDF1, W
0485  0801     MOVF INDF1, W
172:                       MOVLB   0x1F
0486  003F     MOVLB 0x1F
173:                       XORWF   FSR0H_SHAD, W       //read zero
0487  0669     XORWF Timer1GateUser, W
174:                       MOVLW   0X01
0488  3001     MOVLW 0x1
175:                       BTFSS   STATUS, 0x02
0489  1D03     BTFSS STATUS, 0x2
176:                       MOVWF   FSR1L_SHAD
048A  00EA     MOVWF Timer1User
177:           
178:                       MOVF    INDF1, W
048B  0801     MOVF INDF1, W
179:                       BSF     STATUS, 0x00
048C  1403     BSF STATUS, 0x0
180:                       RLF     FSR0H_SHAD, F       //rotate a 1 into bitMask
048D  0DE9     RLF Timer1GateUser, F
181:                       IORWF   FSR0H_SHAD, W
048E  0469     IORWF Timer1GateUser, W
182:                       MOVWF   INDF1               //write 1
048F  0081     MOVWF INDF1
183:           
184:                       //BSF     STATUS, 0x00
185:                       //RLF     FSR0H_SHAD, F
186:                       #endasm
187:                       if (FSR1L_SHAD)
0490  003F     MOVLB 0x1F
0491  086A     MOVF Timer1User, W
0492  1D03     BTFSS STATUS, 0x2
0493  3401     RETLW 0x1
188:                           return CLASSB_TEST_FAIL;
189:                   }
190:                   CLASSB_MarchstartAddress++;
0496  0020     MOVLB 0x0
0497  0AA0     INCF CLASSB_MarchstartAddress, F
0498  1903     BTFSC STATUS, 0x2
0499  0AA1     INCF 0x21, F
191:               }
192:           
193:           /******************************************************************************
194:            * Rd1Wr0 - read one, write zero - ascending
195:            ******************************************************************************/
196:               CLASSB_MarchstartAddress = CLASSB_MARCHtempAddress;
049D  0020     MOVLB 0x0
049E  0825     MOVF 0x25, W
049F  00A1     MOVWF 0x21
04A0  0824     MOVF CLASSB_MARCHtempAddress, W
04A1  00A0     MOVWF CLASSB_MarchstartAddress
197:               for (WREG_SHAD=0; WREG_SHAD<CLASSB_MarchLength; WREG_SHAD++)
04A2  003F     MOVLB 0x1F
04A3  01E5     CLRF InterruptsUser
04A4  0020     MOVLB 0x0
04A5  0826     MOVF CLASSB_MarchLength, W
04A6  003F     MOVLB 0x1F
04A7  0265     SUBWF InterruptsUser, W
04A8  1803     BTFSC STATUS, 0x0
04A9  2CCB     GOTO 0x4CB
04C8  003F     MOVLB 0x1F
04C9  0AE5     INCF InterruptsUser, F
04CA  2CA4     GOTO 0x4A4
198:               {
199:                   FSR0H_SHAD = 0xFF;
04AA  30FF     MOVLW 0xFF
04AB  00E9     MOVWF Timer1GateUser
200:                   for (FSR0L_SHAD=0; FSR0L_SHAD<8; FSR0L_SHAD++)
04AC  01E8     CLRF PIR1User
04AD  3008     MOVLW 0x8
04AE  0268     SUBWF PIR1User, W
04AF  1803     BTFSC STATUS, 0x0
04B0  2CC4     GOTO 0x4C4
04C2  0AE8     INCF PIR1User, F
04C3  2CAD     GOTO 0x4AD
201:                   {
202:                       #asm
203:                       MOVLB   0x00
04B1  0020     MOVLB 0x0
204:                       MOVF    BANKMASK(_CLASSB_MarchstartAddress), W
04B2  0820     MOVF CLASSB_MarchstartAddress, W
205:                       MOVWF   FSR1L
04B3  0086     MOVWF FSR1L
206:                       MOVF    INDF1, W
04B4  0801     MOVF INDF1, W
207:                       MOVLB   0x1F
04B5  003F     MOVLB 0x1F
208:                       XORWF   FSR0H_SHAD, W
04B6  0669     XORWF Timer1GateUser, W
209:                       MOVLW   0X01
04B7  3001     MOVLW 0x1
210:                       BTFSS   STATUS, 0x02
04B8  1D03     BTFSS STATUS, 0x2
211:                       MOVWF   FSR1L_SHAD
04B9  00EA     MOVWF Timer1User
212:           
213:                       MOVF    INDF1, W
04BA  0801     MOVF INDF1, W
214:                       LSLF    FSR0H_SHAD, W
04BB  3569     LSLF Timer1GateUser, W
215:                       MOVWF   INDF1
04BC  0081     MOVWF INDF1
216:           
217:                       LSLF    FSR0H_SHAD, F
04BD  35E9     LSLF Timer1GateUser, F
218:                       #endasm
219:                       if (FSR1L_SHAD)
04BE  003F     MOVLB 0x1F
04BF  086A     MOVF Timer1User, W
04C0  1D03     BTFSS STATUS, 0x2
04C1  3401     RETLW 0x1
220:                           return CLASSB_TEST_FAIL;
221:                   }
222:                   CLASSB_MarchstartAddress++;
04C4  0020     MOVLB 0x0
04C5  0AA0     INCF CLASSB_MarchstartAddress, F
04C6  1903     BTFSC STATUS, 0x2
04C7  0AA1     INCF 0x21, F
223:               }
224:           
225:           /******************************************************************************
226:            * For March C Minus test this section is skipped
227:            * Rd0 - read zero - descending
228:            ******************************************************************************/
229:           #ifndef MARCHCMINUS
230:           
231:               CLASSB_MarchstartAddress = CLASSB_MARCHtempAddress;
232:               for (WREG_SHAD=0; WREG_SHAD < CLASSB_MarchLength; WREG_SHAD++)
233:               {
234:                   FSR0H_SHAD = 0x00;
235:                   for (FSR0L_SHAD=0; FSR0L_SHAD<8; FSR0L_SHAD++)
236:                   {
237:                       #asm
238:                       MOVLB   0x00
239:                       MOVF    BANKMASK(_CLASSB_MarchstartAddress), W
240:                       MOVWF   FSR1L
241:                       MOVF    INDF1, W
242:                       MOVLB   0x1F
243:                       XORWF   FSR0H_SHAD, W       //Read 0
244:                       MOVLW   0x01
245:                       BTFSS   STATUS, 0x02
246:                       MOVWF   FSR1L_SHAD
247:           
248:                       //BSF     STATUS, 0x00
249:                       //RLF     FSR0H_SHAD, F       //rotate a 1 into bitMask
250:                       #endasm
251:                       if (FSR1L_SHAD)
252:                           return CLASSB_TEST_FAIL;
253:                   }
254:                   CLASSB_MarchstartAddress++;
255:               }
256:           
257:           #endif
258:           
259:           /******************************************************************************
260:            * Rd0Wr1 - read zero, write one - descending
261:            ******************************************************************************/
262:           //    CLASSB_MarchstartAddress = CLASSB_MARCHtempAddress + CLASSB_MarchLength - 1;
263:           
264:               CLASSB_MarchstartAddress--;
04CB  3001     MOVLW 0x1
04CC  0020     MOVLB 0x0
04CD  02A0     SUBWF CLASSB_MarchstartAddress, F
04CE  3000     MOVLW 0x0
04CF  3BA1     SUBWFB 0x21, F
265:               CLASSB_MARCHtempAddress = CLASSB_MarchstartAddress;
04D0  0821     MOVF 0x21, W
04D1  00A5     MOVWF 0x25
04D2  0820     MOVF CLASSB_MarchstartAddress, W
04D3  00A4     MOVWF CLASSB_MARCHtempAddress
266:               for (WREG_SHAD=CLASSB_MarchLength; WREG_SHAD>0; WREG_SHAD--)
04D4  0826     MOVF CLASSB_MarchLength, W
04D5  003F     MOVLB 0x1F
04D6  00E5     MOVWF InterruptsUser
04D7  0865     MOVF InterruptsUser, W
04D8  1903     BTFSC STATUS, 0x2
04D9  2CFC     GOTO 0x4FC
04F9  003F     MOVLB 0x1F
04FA  03E5     DECF InterruptsUser, F
04FB  2CD7     GOTO 0x4D7
267:               {
268:                   FSR0H_SHAD = 0x00;
04DA  01E9     CLRF Timer1GateUser
269:                   for (FSR0L_SHAD=0; FSR0L_SHAD<8; FSR0L_SHAD++)
04DB  01E8     CLRF PIR1User
04DC  3008     MOVLW 0x8
04DD  0268     SUBWF PIR1User, W
04DE  1803     BTFSC STATUS, 0x0
04DF  2CF4     GOTO 0x4F4
04F2  0AE8     INCF PIR1User, F
04F3  2CDC     GOTO 0x4DC
270:                   {
271:                       #asm
272:                       MOVLB   0x00
04E0  0020     MOVLB 0x0
273:                       MOVF    BANKMASK(_CLASSB_MarchstartAddress), W
04E1  0820     MOVF CLASSB_MarchstartAddress, W
274:                       MOVWF   FSR1L
04E2  0086     MOVWF FSR1L
275:                       MOVF    INDF1, W
04E3  0801     MOVF INDF1, W
276:                       MOVLB   0x1F
04E4  003F     MOVLB 0x1F
277:                       XORWF   FSR0H_SHAD, W       //Read 0
04E5  0669     XORWF Timer1GateUser, W
278:                       MOVLW   0x01
04E6  3001     MOVLW 0x1
279:                       BTFSS   STATUS, 0x02
04E7  1D03     BTFSS STATUS, 0x2
280:                       MOVWF   FSR1L_SHAD
04E8  00EA     MOVWF Timer1User
281:           
282:                       MOVF    INDF1, W
04E9  0801     MOVF INDF1, W
283:                       BSF     STATUS, 0x00
04EA  1403     BSF STATUS, 0x0
284:                       RRF     FSR0H_SHAD, F       //rotate a 1 into bitMask
04EB  0CE9     RRF Timer1GateUser, F
285:                       IORWF   FSR0H_SHAD, W
04EC  0469     IORWF Timer1GateUser, W
286:                       MOVWF   INDF1               //write 1
04ED  0081     MOVWF INDF1
287:           
288:                       //LSRF    FSR0H_SHAD, F
289:                       #endasm
290:                       if (FSR1L_SHAD)
04EE  003F     MOVLB 0x1F
04EF  086A     MOVF Timer1User, W
04F0  1D03     BTFSS STATUS, 0x2
04F1  3401     RETLW 0x1
291:                           return CLASSB_TEST_FAIL;
292:                   }
293:                   CLASSB_MarchstartAddress--;
04F4  3001     MOVLW 0x1
04F5  0020     MOVLB 0x0
04F6  02A0     SUBWF CLASSB_MarchstartAddress, F
04F7  3000     MOVLW 0x0
04F8  3BA1     SUBWFB 0x21, F
294:           
295:               }
296:           
297:           /******************************************************************************
298:            * Rd1Wr0 - read one, write zero - descending
299:            ******************************************************************************/
300:               CLASSB_MarchstartAddress = CLASSB_MARCHtempAddress;
04FC  0020     MOVLB 0x0
04FD  0825     MOVF 0x25, W
04FE  00A1     MOVWF 0x21
04FF  0824     MOVF CLASSB_MARCHtempAddress, W
0500  00A0     MOVWF CLASSB_MarchstartAddress
301:               for (WREG_SHAD=CLASSB_MarchLength; WREG_SHAD>0; WREG_SHAD--)
0501  0826     MOVF CLASSB_MarchLength, W
0502  003F     MOVLB 0x1F
0503  00E5     MOVWF InterruptsUser
0504  0865     MOVF InterruptsUser, W
0505  1903     BTFSC STATUS, 0x2
0506  2D29     GOTO 0x529
0526  003F     MOVLB 0x1F
0527  03E5     DECF InterruptsUser, F
0528  2D04     GOTO 0x504
302:               {
303:                   FSR0H_SHAD = 0xFF;
0507  30FF     MOVLW 0xFF
0508  00E9     MOVWF Timer1GateUser
304:                   for (FSR0L_SHAD=0; FSR0L_SHAD<8; FSR0L_SHAD++)
0509  01E8     CLRF PIR1User
050A  3008     MOVLW 0x8
050B  0268     SUBWF PIR1User, W
050C  1803     BTFSC STATUS, 0x0
050D  2D21     GOTO 0x521
051F  0AE8     INCF PIR1User, F
0520  2D0A     GOTO 0x50A
305:                   {
306:                       #asm
307:                       MOVLB   0x00
050E  0020     MOVLB 0x0
308:                       MOVF    BANKMASK(_CLASSB_MarchstartAddress), W
050F  0820     MOVF CLASSB_MarchstartAddress, W
309:                       MOVWF   FSR1L
0510  0086     MOVWF FSR1L
310:                       MOVF    INDF1, W
0511  0801     MOVF INDF1, W
311:                       MOVLB   0x1F
0512  003F     MOVLB 0x1F
312:                       XORWF   FSR0H_SHAD, W
0513  0669     XORWF Timer1GateUser, W
313:                       MOVLW   0x01
0514  3001     MOVLW 0x1
314:                       BTFSS   STATUS, 0x02
0515  1D03     BTFSS STATUS, 0x2
315:                       MOVWF   FSR1L_SHAD
0516  00EA     MOVWF Timer1User
316:           
317:                       MOVF    INDF1, W
0517  0801     MOVF INDF1, W
318:                       LSRF    FSR0H_SHAD, W
0518  3669     LSRF Timer1GateUser, W
319:                       MOVWF   INDF1
0519  0081     MOVWF INDF1
320:           
321:                       LSRF    FSR0H_SHAD, F
051A  36E9     LSRF Timer1GateUser, F
322:                       #endasm
323:                       if (FSR1L_SHAD)
051B  003F     MOVLB 0x1F
051C  086A     MOVF Timer1User, W
051D  1D03     BTFSS STATUS, 0x2
051E  3401     RETLW 0x1
324:                           return CLASSB_TEST_FAIL;
325:                   }
326:                   CLASSB_MarchstartAddress--;
0521  3001     MOVLW 0x1
0522  0020     MOVLB 0x0
0523  02A0     SUBWF CLASSB_MarchstartAddress, F
0524  3000     MOVLW 0x0
0525  3BA1     SUBWFB 0x21, F
327:               }
328:           
329:           /******************************************************************************
330:            * Rd0 - read zero - descending
331:            ******************************************************************************/
332:               CLASSB_MarchstartAddress = CLASSB_MARCHtempAddress;
0529  0020     MOVLB 0x0
052A  0825     MOVF 0x25, W
052B  00A1     MOVWF 0x21
052C  0824     MOVF CLASSB_MARCHtempAddress, W
052D  00A0     MOVWF CLASSB_MarchstartAddress
333:               for (WREG_SHAD=(CLASSB_MarchLength-1); WREG_SHAD>0; WREG_SHAD--)
052E  0826     MOVF CLASSB_MarchLength, W
052F  3EFF     ADDLW 0xFF
0530  003F     MOVLB 0x1F
0531  00E5     MOVWF InterruptsUser
0532  0865     MOVF InterruptsUser, W
0533  1903     BTFSC STATUS, 0x2
0534  2D52     GOTO 0x552
054F  003F     MOVLB 0x1F
0550  03E5     DECF InterruptsUser, F
0551  2D32     GOTO 0x532
334:               {
335:                   FSR0H_SHAD = 0x00;
0535  01E9     CLRF Timer1GateUser
336:                   for (FSR0L_SHAD=0; FSR0L_SHAD<8; FSR0L_SHAD++)
0536  01E8     CLRF PIR1User
0537  3008     MOVLW 0x8
0538  0268     SUBWF PIR1User, W
0539  1803     BTFSC STATUS, 0x0
053A  2D4A     GOTO 0x54A
0548  0AE8     INCF PIR1User, F
0549  2D37     GOTO 0x537
337:                   {
338:                       #asm
339:                       MOVLB   0x00
053B  0020     MOVLB 0x0
340:                       MOVF    BANKMASK(_CLASSB_MarchstartAddress), W
053C  0820     MOVF CLASSB_MarchstartAddress, W
341:                       MOVWF   FSR1L
053D  0086     MOVWF FSR1L
342:                       MOVF    INDF1, W
053E  0801     MOVF INDF1, W
343:                       MOVLB   0x1F
053F  003F     MOVLB 0x1F
344:                       XORWF   FSR0H_SHAD, W
0540  0669     XORWF Timer1GateUser, W
345:           //            BTFSS   STATUS, 0x02
346:           //            RETLW   0x01
347:                       MOVLW   0x01
0541  3001     MOVLW 0x1
348:                       BTFSS   STATUS, 0x02
0542  1D03     BTFSS STATUS, 0x2
349:                       //MOVLW   0x01
350:                       MOVWF   FSR1L_SHAD
0543  00EA     MOVWF Timer1User
351:           
352:                       //LSRF    FSR0H_SHAD, F
353:                       #endasm
354:                       if (FSR1L_SHAD)
0544  003F     MOVLB 0x1F
0545  086A     MOVF Timer1User, W
0546  1D03     BTFSS STATUS, 0x2
0547  3401     RETLW 0x1
355:                           return 1;
356:                   }
357:                   CLASSB_MarchstartAddress--;
054A  3001     MOVLW 0x1
054B  0020     MOVLB 0x0
054C  02A0     SUBWF CLASSB_MarchstartAddress, F
054D  3000     MOVLW 0x0
054E  3BA1     SUBWFB 0x21, F
358:               }
359:           //    CLASSB_MarchstartAddress++;
360:               
361:           /******************************************************************************
362:            * March C (Minus) Test Passed
363:            ******************************************************************************/
364:               if (CLASSB_MarchbufferAddress != NULL)
0552  0020     MOVLB 0x0
0553  0823     MOVF 0x23, W
0554  0422     IORWF CLASSB_MarchbufferAddress, W
0555  1903     BTFSC STATUS, 0x2
0556  3400     RETLW 0x0
365:               {
366:                   CLASSB_MARCHtempAddress = (CLASSB_MarchbufferAddress - CLASSB_MarchLength);
0557  0823     MOVF 0x23, W
0558  00A5     MOVWF 0x25
0559  0822     MOVF CLASSB_MarchbufferAddress, W
055A  00A4     MOVWF CLASSB_MARCHtempAddress
055B  0826     MOVF CLASSB_MarchLength, W
055C  02A4     SUBWF CLASSB_MARCHtempAddress, F
055D  1C03     BTFSS STATUS, 0x0
055E  03A5     DECF 0x25, F
367:                   for (WREG_SHAD = CLASSB_MarchLength; WREG_SHAD != 0; WREG_SHAD--)
055F  003F     MOVLB 0x1F
0560  00E5     MOVWF InterruptsUser
0561  0865     MOVF InterruptsUser, W
0562  1903     BTFSC STATUS, 0x2
0563  3400     RETLW 0x0
0575  003F     MOVLB 0x1F
0576  03E5     DECF InterruptsUser, F
0577  2D61     GOTO 0x561
368:                   {
369:                       *CLASSB_MarchstartAddress++ = *CLASSB_MARCHtempAddress++;
0564  0020     MOVLB 0x0
0565  0820     MOVF CLASSB_MarchstartAddress, W
0566  0086     MOVWF FSR1L
0567  0821     MOVF 0x21, W
0568  0087     MOVWF FSR1H
0569  0824     MOVF CLASSB_MARCHtempAddress, W
056A  0084     MOVWF FSR0L
056B  0825     MOVF 0x25, W
056C  0085     MOVWF FSR0H
056D  0800     MOVF INDF0, W
056E  0081     MOVWF INDF1
056F  0AA4     INCF CLASSB_MARCHtempAddress, F
0570  1903     BTFSC STATUS, 0x2
0571  0AA5     INCF 0x25, F
0572  0AA0     INCF CLASSB_MarchstartAddress, F
0573  1903     BTFSC STATUS, 0x2
0574  0AA1     INCF 0x21, F
370:                   }
371:               }
372:               return CLASSB_TEST_PASS;
373:           
374:           } // End of function
375:           
376:           
377:           /***********************************************************
378:           * Description:
379:           *     This function sets up the memory for a failure.
380:           *     With this the MarchCstartAddress will still be at the 
381:           *     at the address of the failure!
382:           ***********************************************************/
383:           //void MarchCFailure (void)
384:           //{
385:           //    if (CLASSB_MarchbufferAddress != NULL)
386:           //        memcpy(CLASSB_MARCHtempAddress, CLASSB_MarchbufferAddress, CLASSB_MarchLength); //restore user memory
387:           //}
388:           
389:           /***********************************************************
390:           * Description:
391:           *     This function runs the March C test on the 7 RAM 
392:           *     addresses used to run the rest of the March C test.
393:           ***********************************************************/
394:           CLASSBRESULT MarchCGlobalTest (void)
395:           {
396:           
397:           #asm
398:               MOVLB 0x00
0578  0020     MOVLB 0x0
399:               MOVF 0x20, W
0579  0820     MOVF CLASSB_MarchstartAddress, W
400:               MOVWF FSR0L         //CLASSB_MarchstartAddress
057A  0084     MOVWF FSR0L
401:               MOVF 0x22, W
057B  0822     MOVF CLASSB_MarchbufferAddress, W
402:               MOVWF FSR0H         //CLASSB_MarchbufferAddress
057C  0085     MOVWF FSR0H
403:               MOVF 0x26, W
057D  0826     MOVF CLASSB_MarchLength, W
404:               MOVLB 0x1F
057E  003F     MOVLB 0x1F
405:               MOVWF WREG_SHAD     //CLASSB_MarchLength
057F  00E5     MOVWF InterruptsUser
406:               MOVF FSR0L, W
0580  0804     MOVF FSR0L, W
407:               MOVWF FSR0L_SHAD    //CLASSB_MarchstartAddress
0581  00E8     MOVWF PIR1User
408:               MOVF FSR0H, W
0582  0805     MOVF FSR0H, W
409:               MOVWF FSR0H_SHAD    //CLASSB_MarchbufferAddress
0583  00E9     MOVWF Timer1GateUser
410:           #endasm
411:           
412:               uint8_t* tempAddrPTR;
413:               uint8_t r;
414:               uint8_t i;
415:               uint8_t bitMask;
416:           
417:               tempAddrPTR = (char*)0x20;
0584  3020     MOVLW 0x20
0585  0020     MOVLB 0x0
0586  00AB     MOVWF n
0587  01AC     CLRF 0x2C
418:           
419:               //(^w0)(^r0,w1)(^r1,w0)
420:               //(!M^r0)(/r0,w1)(/r1,w0)(^r0)
421:           
422:               //write 0 - ascending
423:               for(r = 0; r < 7; r++)
0588  01AA     CLRF crcSeed
0591  3007     MOVLW 0x7
0592  0AAA     INCF crcSeed, F
0593  022A     SUBWF crcSeed, W
0594  1C03     BTFSS STATUS, 0x0
0595  2D89     GOTO 0x589
424:               {
425:                   *tempAddrPTR = 0;
0589  082B     MOVF n, W
058A  0086     MOVWF FSR1L
058B  082C     MOVF 0x2C, W
058C  0087     MOVWF FSR1H
058D  0181     CLRF INDF1
426:                   tempAddrPTR++;
058E  0AAB     INCF n, F
058F  1903     BTFSC STATUS, 0x2
0590  0AAC     INCF 0x2C, F
427:               }
428:           
429:               //read zero, write one - ascending
430:               tempAddrPTR = (char*)0x20;
0596  3020     MOVLW 0x20
0597  00AB     MOVWF n
0598  01AC     CLRF 0x2C
431:               for(r = 0; r < 7; r++)
0599  01AA     CLRF crcSeed
05BB  3007     MOVLW 0x7
05BC  0AAA     INCF crcSeed, F
05BD  022A     SUBWF crcSeed, W
05BE  1C03     BTFSS STATUS, 0x0
05BF  2D9A     GOTO 0x59A
432:               {
433:                   bitMask = 0x01;
059A  01A9     CLRF s1
059B  0AA9     INCF s1, F
434:                   for(i = 0; i < 8; i++)
059C  01A8     CLRF length
05B2  3008     MOVLW 0x8
05B4  0AA8     INCF length, F
05B5  0228     SUBWF length, W
05B6  1C03     BTFSS STATUS, 0x0
05B7  2D9D     GOTO 0x59D
435:                   {
436:                       if(*tempAddrPTR & bitMask)
059D  082B     MOVF n, W
059E  0086     MOVWF FSR1L
059F  082C     MOVF 0x2C, W
05A0  0087     MOVWF FSR1H
05A1  0801     MOVF INDF1, W
05A2  0529     ANDWF s1, W
05A3  1D03     BTFSS STATUS, 0x2
437:                       {
438:                           return CLASSB_TEST_FAIL;
05A4  3401     RETLW 0x1
439:                       }
440:                       else
441:                       {
442:                           *tempAddrPTR = *tempAddrPTR | bitMask;
05A5  082B     MOVF n, W
05A6  0086     MOVWF FSR1L
05A7  082C     MOVF 0x2C, W
05A8  0087     MOVWF FSR1H
05A9  0801     MOVF INDF1, W
05AA  0429     IORWF s1, W
05AB  00A7     MOVWF d1
05AC  082B     MOVF n, W
05AD  0086     MOVWF FSR1L
05AE  082C     MOVF 0x2C, W
05AF  0087     MOVWF FSR1H
05B0  0827     MOVF d1, W
05B1  0081     MOVWF INDF1
443:                       }
444:                       bitMask <<= 1;
05B3  35A9     LSLF s1, F
445:                   }
446:                   tempAddrPTR++;
05B8  0AAB     INCF n, F
05B9  1903     BTFSC STATUS, 0x2
05BA  0AAC     INCF 0x2C, F
447:               }
448:           
449:               //read one, write zero - ascending
450:               tempAddrPTR = (char*)0x20;
05C0  3020     MOVLW 0x20
05C1  00AB     MOVWF n
05C2  01AC     CLRF 0x2C
451:               for(r = 0; r < 7; r++)
05C3  01AA     CLRF crcSeed
05E5  3007     MOVLW 0x7
05E6  0AAA     INCF crcSeed, F
05E7  022A     SUBWF crcSeed, W
05E8  1C03     BTFSS STATUS, 0x0
05E9  2DC4     GOTO 0x5C4
452:               {
453:                   bitMask = 0x01;
05C4  01A9     CLRF s1
05C5  0AA9     INCF s1, F
454:                   for(i = 0; i < 8; i++)
05C6  01A8     CLRF length
05DC  3008     MOVLW 0x8
05DE  0AA8     INCF length, F
05DF  0228     SUBWF length, W
05E0  1C03     BTFSS STATUS, 0x0
05E1  2DC7     GOTO 0x5C7
455:                   {
456:                       if(*tempAddrPTR & bitMask)
05C7  082B     MOVF n, W
05C8  0086     MOVWF FSR1L
05C9  082C     MOVF 0x2C, W
05CA  0087     MOVWF FSR1H
05CB  0801     MOVF INDF1, W
05CC  0529     ANDWF s1, W
05CD  1903     BTFSC STATUS, 0x2
05CE  3401     RETLW 0x1
457:                       {
458:                           *tempAddrPTR = *tempAddrPTR & ~bitMask;
05CF  082B     MOVF n, W
05D0  0086     MOVWF FSR1L
05D1  082C     MOVF 0x2C, W
05D2  0087     MOVWF FSR1H
05D3  0929     COMF s1, W
05D4  0501     ANDWF INDF1, W
05D5  00A7     MOVWF d1
05D6  082B     MOVF n, W
05D7  0086     MOVWF FSR1L
05D8  082C     MOVF 0x2C, W
05D9  0087     MOVWF FSR1H
05DA  0827     MOVF d1, W
05DB  0081     MOVWF INDF1
459:                       }
460:                       else
461:                       {
462:                           return CLASSB_TEST_FAIL;
463:                       }
464:                       bitMask <<= 1;
05DD  35A9     LSLF s1, F
465:                   }
466:                   tempAddrPTR++;
05E2  0AAB     INCF n, F
05E3  1903     BTFSC STATUS, 0x2
05E4  0AAC     INCF 0x2C, F
467:               }
468:           
469:               //NOT MINUS test
470:               //read zero - ascending
471:           #ifndef MARCHCMINUS
472:               tempAddrPTR = (char*)0x20;
473:               for(r = 0; r < 7; r++)
474:               {
475:                   if (*tempAddrPTR != 0)
476:                   {
477:                       return CLASSB_TEST_FAIL;
478:                   }
479:                   tempAddrPTR++;
480:               }
481:           #endif
482:           
483:               //read zero, write one - descending
484:               tempAddrPTR = (char*)0x26;
05EA  3026     MOVLW 0x26
05EB  00AB     MOVWF n
05EC  01AC     CLRF 0x2C
485:               for (r = 0; r < 7; r++)
05ED  01AA     CLRF crcSeed
0610  3007     MOVLW 0x7
0611  0AAA     INCF crcSeed, F
0612  022A     SUBWF crcSeed, W
0613  1C03     BTFSS STATUS, 0x0
0614  2DEE     GOTO 0x5EE
486:               {
487:                   bitMask = 0x80;
05EE  3080     MOVLW 0x80
05EF  00A9     MOVWF s1
488:                   for (i=0; i<8; i++)
05F0  01A8     CLRF length
0606  3008     MOVLW 0x8
0608  0AA8     INCF length, F
0609  0228     SUBWF length, W
060A  1C03     BTFSS STATUS, 0x0
060B  2DF1     GOTO 0x5F1
489:                   {
490:                       if(*tempAddrPTR & bitMask)
05F1  082B     MOVF n, W
05F2  0086     MOVWF FSR1L
05F3  082C     MOVF 0x2C, W
05F4  0087     MOVWF FSR1H
05F5  0801     MOVF INDF1, W
05F6  0529     ANDWF s1, W
05F7  1D03     BTFSS STATUS, 0x2
05F8  3401     RETLW 0x1
491:                       {
492:                           return CLASSB_TEST_FAIL;
493:                       }
494:                       else
495:                       {
496:                           *tempAddrPTR = *tempAddrPTR | bitMask;
05F9  082B     MOVF n, W
05FA  0086     MOVWF FSR1L
05FB  082C     MOVF 0x2C, W
05FC  0087     MOVWF FSR1H
05FD  0801     MOVF INDF1, W
05FE  0429     IORWF s1, W
05FF  00A7     MOVWF d1
0600  082B     MOVF n, W
0601  0086     MOVWF FSR1L
0602  082C     MOVF 0x2C, W
0603  0087     MOVWF FSR1H
0604  0827     MOVF d1, W
0605  0081     MOVWF INDF1
497:                       }
498:                       bitMask>>=1;
0607  36A9     LSRF s1, F
499:                   }
500:                   tempAddrPTR--;
060C  3001     MOVLW 0x1
060D  02AB     SUBWF n, F
060E  3000     MOVLW 0x0
060F  3BAC     SUBWFB 0x2C, F
501:               }
502:           
503:               //read one, write zero - descending
504:               tempAddrPTR = (char*)0x26;
0615  3026     MOVLW 0x26
0616  00AB     MOVWF n
0617  01AC     CLRF 0x2C
505:               for (r = 0; r < 7; r++)
0618  01AA     CLRF crcSeed
063B  3007     MOVLW 0x7
063C  0AAA     INCF crcSeed, F
063D  022A     SUBWF crcSeed, W
063E  1C03     BTFSS STATUS, 0x0
063F  2E19     GOTO 0x619
506:               {
507:                   bitMask = 0x80;
0619  3080     MOVLW 0x80
061A  00A9     MOVWF s1
508:                   for(i = 0; i < 8; i++)
061B  01A8     CLRF length
0631  3008     MOVLW 0x8
0633  0AA8     INCF length, F
0634  0228     SUBWF length, W
0635  1C03     BTFSS STATUS, 0x0
0636  2E1C     GOTO 0x61C
509:                   {
510:                       if(*tempAddrPTR & bitMask)
061C  082B     MOVF n, W
061D  0086     MOVWF FSR1L
061E  082C     MOVF 0x2C, W
061F  0087     MOVWF FSR1H
0620  0801     MOVF INDF1, W
0621  0529     ANDWF s1, W
0622  1903     BTFSC STATUS, 0x2
0623  3401     RETLW 0x1
511:                       {
512:                           *tempAddrPTR = *tempAddrPTR & ~bitMask;
0624  082B     MOVF n, W
0625  0086     MOVWF FSR1L
0626  082C     MOVF 0x2C, W
0627  0087     MOVWF FSR1H
0628  0929     COMF s1, W
0629  0501     ANDWF INDF1, W
062A  00A7     MOVWF d1
062B  082B     MOVF n, W
062C  0086     MOVWF FSR1L
062D  082C     MOVF 0x2C, W
062E  0087     MOVWF FSR1H
062F  0827     MOVF d1, W
0630  0081     MOVWF INDF1
513:                       }
514:                       else
515:                       {
516:                           return CLASSB_TEST_FAIL;
517:                       }
518:                       bitMask >>= 1;
0632  36A9     LSRF s1, F
519:                   }
520:                   tempAddrPTR--;
0637  3001     MOVLW 0x1
0638  02AB     SUBWF n, F
0639  3000     MOVLW 0x0
063A  3BAC     SUBWFB 0x2C, F
521:               }
522:           
523:               //read zero - ascending
524:               tempAddrPTR = (char*)0x20;
0640  3020     MOVLW 0x20
0641  00AB     MOVWF n
0642  01AC     CLRF 0x2C
525:               for(r = 0; r < 7; r++)
0643  01AA     CLRF crcSeed
064F  3007     MOVLW 0x7
0650  0AAA     INCF crcSeed, F
0651  022A     SUBWF crcSeed, W
0652  1C03     BTFSS STATUS, 0x0
0653  2E44     GOTO 0x644
526:               {
527:                   if (*tempAddrPTR != 0)
0644  082B     MOVF n, W
0645  0086     MOVWF FSR1L
0646  082C     MOVF 0x2C, W
0647  0087     MOVWF FSR1H
0648  0801     MOVF INDF1, W
0649  3A00     XORLW 0x0
064A  1D03     BTFSS STATUS, 0x2
064B  3401     RETLW 0x1
528:                   {
529:                       return CLASSB_TEST_FAIL;
530:                   }
531:                   tempAddrPTR++;
064C  0AAB     INCF n, F
064D  1903     BTFSC STATUS, 0x2
064E  0AAC     INCF 0x2C, F
532:               }
533:           
534:           #asm
535:               MOVLB 0x1F
0654  003F     MOVLB 0x1F
536:               MOVF FSR0L_SHAD, W
0655  0868     MOVF PIR1User, W
537:               MOVWF FSR0L         //CLASSB_MarchstartAddress
0656  0084     MOVWF FSR0L
538:               MOVF FSR0H_SHAD, W
0657  0869     MOVF Timer1GateUser, W
539:               MOVWF FSR0H         //CLASSB_MarchbufferAddress
0658  0085     MOVWF FSR0H
540:               MOVF WREG_SHAD, W
0659  0865     MOVF InterruptsUser, W
541:               MOVLB 0x00
065A  0020     MOVLB 0x0
542:               MOVWF 0x26     //CLASSB_MarchLength
065B  00A6     MOVWF CLASSB_MarchLength
543:               MOVF FSR0L, W
065C  0804     MOVF FSR0L, W
544:               MOVWF 0x20    //CLASSB_MarchstartAddress
065D  00A0     MOVWF CLASSB_MarchstartAddress
545:               MOVF FSR0H, W
065E  0805     MOVF FSR0H, W
546:               MOVWF 0x22    //CLASSB_MarchbufferAddress
065F  00A2     MOVWF CLASSB_MarchbufferAddress
547:           #endasm
548:           
549:               return CLASSB_TEST_PASS;
0660  3400     RETLW 0x0
550:           }
0661  003F     MOVLB 0x1F
1:             /**********************************************************************
2:             * © 2013 Microchip Technology Inc.
3:             *
4:             * Project Name:     Class B Library
5:             * FileName:         CLASSB_RAMMarchCTest.c
6:             * Dependencies:     CLASSB_RAMMarchCTest.h
7:             * Processor:        PIC16F1xxx
8:             * Compiler:         XC8
9:             * IDE:              MPLAB® IDE or MPLAB® X
10:            * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
11:            * Description:     This file contains functions to RAM with MarchC Test.
12:            *
13:            **************************************************************************
14:             * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER: You may use this software, and
15:             * any derivatives created by any person or entity by or on your behalf,
16:             * exclusively with Microchip's products in accordance with applicable
17:             * software license terms and conditions, a copy of which is provided for
18:             * your referencein accompanying documentation. Microchip and its licensors
19:             * retain all ownership and intellectual property rights in the
20:             * accompanying software and in all derivatives hereto.
21:             *
22:             * This software and any accompanying information is for suggestion only.
23:             * It does not modify Microchip's standard warranty for its products. You
24:             * agree that you are solely responsible for testing the software and
25:             * determining its suitability. Microchip has no obligation to modify,
26:             * test, certify, or support the software.
27:             *
28:             * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:             * EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED
30:             * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:             * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE, ITS INTERACTION WITH
32:             * MICROCHIP'S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
33:             * APPLICATION.
34:             *
35:             * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY,
36:             * TORT (INCLUDING NEGLIGENCE OR BREACH OF STATUTORY DUTY), STRICT
37:             * LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT,
38:             * SPECIAL, PUNITIVE, EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE,
39:             * FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE SOFTWARE,
40:             * HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY
41:             * OR THE DAMAGES ARE FORESEEABLE. TO THE FULLEST EXTENT ALLOWABLE BY LAW,
42:             * MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
43:             * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID
44:             * DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
45:             *
46:             * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
47:             * THESE TERMS.
48:             *************************************************************************
49:            *
50:            * REVISION HISTORY:
51:            *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
52:            * Author            Date      Comments on this revision
53:            *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
54:            * CT                09/15/2008  First release of source file
55:            * Mike Cahill       11/11/2010	Updated for HI-TECH v9.80
56:            * MVL               02/22/2011	Modified for HI-TECH v9.81
57:            * EA                02/18/2012	Made corrections to March C Minus routine
58:            * Corey Simoncic    04/19/2013  Updated for XC-8
59:            *
60:            * Version       3.00
61:            *
62:            *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
63:            * ADDITIONAL NOTES:
64:            *
65:            **********************************************************************/
66:            
67:            #include "CLASSB_RAMMarchCStackTest.h"
68:            
69:            //Comment if used in conjunction with the March C test!
70:            
71:            #ifndef MARCH_VARS
72:            #define MARCH_VARS
73:            unsigned char* CLASSB_MarchstartAddress @ 0x20;
74:            unsigned char* CLASSB_MarchbufferAddress @ 0x22;
75:            unsigned char* CLASSB_MARCHtempAddress @ 0x24;
76:            unsigned char CLASSB_MarchLength @ 0x26 = 0;
77:            #endif
78:            
79:            unsigned char stackTestResult;
80:            
81:            /***********************************************************
82:             *
83:             * Description:
84:             *    This function performs the March C test on the stack.
85:             *    If the March C Minus test is desired set minus = 1
86:             * Inputs:
87:             *    *CLASSB_MarchCbufferAddress    :   pointer to the location to store memory during test
88:             *    MARCHCMINUS                    :   designates the test is a March C Minus test.
89:             *
90:             * ********************************************************/
91:            CLASSBRESULT CLASSB_RAMMarchCStackTest(void)
92:            {
93:                    volatile unsigned char i;
94:            
95:            /*****************************************************************************
96:            * Save Stack here.
97:            * ***************************************************************************/
98:                    *CLASSB_MarchbufferAddress = STKPTR;
0661  003F     MOVLB 0x1F
99:            
100:                   CLASSB_MarchbufferAddress++;
066B  0AA2     INCF CLASSB_MarchbufferAddress, F
066C  1903     BTFSC STATUS, 0x2
066D  0AA3     INCF 0x23, F
101:           
102:                   for (WREG_SHAD = 0; WREG_SHAD <= 15; WREG_SHAD++)
066E  003F     MOVLB 0x1F
066F  01E5     CLRF InterruptsUser
0670  3010     MOVLW 0x10
0671  0265     SUBWF InterruptsUser, W
0672  1803     BTFSC STATUS, 0x0
0673  2E92     GOTO 0x692
068F  003F     MOVLB 0x1F
0690  0AE5     INCF InterruptsUser, F
0691  2E70     GOTO 0x670
103:                   {
104:                       STKPTR = WREG_SHAD;
0674  0865     MOVF InterruptsUser, W
0675  00ED     MOVWF parity
105:                       *CLASSB_MarchbufferAddress = TOSL;
0676  086E     MOVF stackTestResult, W
0677  0020     MOVLB 0x0
0678  00A7     MOVWF d1
0679  0822     MOVF CLASSB_MarchbufferAddress, W
067A  0086     MOVWF FSR1L
067B  0823     MOVF 0x23, W
067C  0087     MOVWF FSR1H
067D  0827     MOVF d1, W
067E  0081     MOVWF INDF1
106:                       CLASSB_MarchbufferAddress++;
067F  0AA2     INCF CLASSB_MarchbufferAddress, F
0680  1903     BTFSC STATUS, 0x2
0681  0AA3     INCF 0x23, F
107:                       *CLASSB_MarchbufferAddress = TOSH;
0682  003F     MOVLB 0x1F
0683  086F     MOVF tempBSR, W
0684  0020     MOVLB 0x0
0685  00A7     MOVWF d1
0686  0822     MOVF CLASSB_MarchbufferAddress, W
0687  0086     MOVWF FSR1L
0688  0823     MOVF 0x23, W
0689  0087     MOVWF FSR1H
068A  0827     MOVF d1, W
068B  0081     MOVWF INDF1
108:                       CLASSB_MarchbufferAddress++;
068C  0AA2     INCF CLASSB_MarchbufferAddress, F
068D  1903     BTFSC STATUS, 0x2
068E  0AA3     INCF 0x23, F
109:                   }
110:           
111:           /*****************************************************************************
112:           * Run Stack Test here.
113:           * ***************************************************************************/
114:           
115:           //Write zero into stack
116:           //        STKPTR = 0;
117:                   #asm
118:                   MOVLB   0x1F
0692  003F     MOVLB 0x1F
119:                   MOVLW   0x1F
0693  301F     MOVLW 0x1F
120:                   MOVWF   STKPTR
0694  00ED     MOVWF parity
121:                   Wr0:
122:                   INCF    STKPTR
0695  0AED     INCF parity, F
123:                   CLRF    TOSL
0696  01EE     CLRF stackTestResult
124:                   CLRF    TOSH
0697  01EF     CLRF tempBSR
125:                   MOVF    STKPTR, W
0698  086D     MOVF parity, W
126:                   XORLW   0x0F
0699  3A0F     XORLW 0xF
127:                   BTFSS   STATUS, 0x02
069A  1D03     BTFSS STATUS, 0x2
128:                   GOTO    Wr0
069B  2E95     GOTO 0x695
129:           
130:           //Read zero, Write one - ascending
131:                   MOVLW   0x1F
069C  301F     MOVLW 0x1F
132:                   MOVWF   STKPTR
069D  00ED     MOVWF parity
133:                   Rd0Wr1ASC:
134:                   INCF    STKPTR
069E  0AED     INCF parity, F
135:                   BTFSC   TOSL,0
069F  186E     BTFSC stackTestResult, 0x0
136:                   GOTO    STACKFAIL
06A0  2F7A     GOTO 0x77A
137:                   BSF     TOSL,0
06A1  146E     BSF stackTestResult, 0x0
138:                   BTFSC   TOSL,1
06A2  18EE     BTFSC stackTestResult, 0x1
139:                   GOTO    STACKFAIL
06A3  2F7A     GOTO 0x77A
140:                   BSF     TOSL,1
06A4  14EE     BSF stackTestResult, 0x1
141:                   BTFSC   TOSL,2
06A5  196E     BTFSC stackTestResult, 0x2
142:                   GOTO    STACKFAIL
06A6  2F7A     GOTO 0x77A
143:                   BSF     TOSL,2
06A7  156E     BSF stackTestResult, 0x2
144:                   BTFSC   TOSL,3
06A8  19EE     BTFSC stackTestResult, 0x3
145:                   GOTO    STACKFAIL
06A9  2F7A     GOTO 0x77A
146:                   BSF     TOSL,3
06AA  15EE     BSF stackTestResult, 0x3
147:                   BTFSC   TOSL,4
06AB  1A6E     BTFSC stackTestResult, 0x4
148:                   GOTO    STACKFAIL
06AC  2F7A     GOTO 0x77A
149:                   BSF     TOSL,4
06AD  166E     BSF stackTestResult, 0x4
150:                   BTFSC   TOSL,5
06AE  1AEE     BTFSC stackTestResult, 0x5
151:                   GOTO    STACKFAIL
06AF  2F7A     GOTO 0x77A
152:                   BSF     TOSL,5
06B0  16EE     BSF stackTestResult, 0x5
153:                   BTFSC   TOSL,6
06B1  1B6E     BTFSC stackTestResult, 0x6
154:                   GOTO    STACKFAIL
06B2  2F7A     GOTO 0x77A
155:                   BSF     TOSL,6
06B3  176E     BSF stackTestResult, 0x6
156:                   BTFSC   TOSL,7
06B4  1BEE     BTFSC stackTestResult, 0x7
157:                   GOTO    STACKFAIL
06B5  2F7A     GOTO 0x77A
158:                   BSF     TOSL,7
06B6  17EE     BSF stackTestResult, 0x7
159:                   BTFSC   TOSH,0
06B7  186F     BTFSC tempBSR, 0x0
160:                   GOTO    STACKFAIL
06B8  2F7A     GOTO 0x77A
161:                   BSF     TOSH,0
06B9  146F     BSF tempBSR, 0x0
162:                   BTFSC   TOSH,1
06BA  18EF     BTFSC tempBSR, 0x1
163:                   GOTO    STACKFAIL
06BB  2F7A     GOTO 0x77A
164:                   BSF     TOSH,1
06BC  14EF     BSF tempBSR, 0x1
165:                   BTFSC   TOSH,2
06BD  196F     BTFSC tempBSR, 0x2
166:                   GOTO    STACKFAIL
06BE  2F7A     GOTO 0x77A
167:                   BSF     TOSH,2
06BF  156F     BSF tempBSR, 0x2
168:                   BTFSC   TOSH,3
06C0  19EF     BTFSC tempBSR, 0x3
169:                   GOTO    STACKFAIL
06C1  2F7A     GOTO 0x77A
170:                   BSF     TOSH,3
06C2  15EF     BSF tempBSR, 0x3
171:                   BTFSC   TOSH,4
06C3  1A6F     BTFSC tempBSR, 0x4
172:                   GOTO    STACKFAIL
06C4  2F7A     GOTO 0x77A
173:                   BSF     TOSH,4
06C5  166F     BSF tempBSR, 0x4
174:                   BTFSC   TOSH,5
06C6  1AEF     BTFSC tempBSR, 0x5
175:                   GOTO    STACKFAIL
06C7  2F7A     GOTO 0x77A
176:                   BSF     TOSH,5
06C8  16EF     BSF tempBSR, 0x5
177:                   BTFSC   TOSH,6
06C9  1B6F     BTFSC tempBSR, 0x6
178:                   GOTO    STACKFAIL
06CA  2F7A     GOTO 0x77A
179:                   BSF     TOSH,6
06CB  176F     BSF tempBSR, 0x6
180:                   MOVF    STKPTR, W
06CC  086D     MOVF parity, W
181:                   XORLW   0x0F
06CD  3A0F     XORLW 0xF
182:                   BTFSS   STATUS, 0x02
06CE  1D03     BTFSS STATUS, 0x2
183:                   GOTO    Rd0Wr1ASC
06CF  2E9E     GOTO 0x69E
184:           
185:           //Read one, Write zero - ascending
186:                   MOVLW   0x1F
06D0  301F     MOVLW 0x1F
187:                   MOVWF   STKPTR
06D1  00ED     MOVWF parity
188:                   Rd1Wr0ASC:
189:                   INCF    STKPTR
06D2  0AED     INCF parity, F
190:                   BTFSS   TOSL,0
06D3  1C6E     BTFSS stackTestResult, 0x0
191:                   GOTO    STACKFAIL
06D4  2F7A     GOTO 0x77A
192:                   BCF     TOSL,0
06D5  106E     BCF stackTestResult, 0x0
193:                   BTFSS   TOSL,1
06D6  1CEE     BTFSS stackTestResult, 0x1
194:                   GOTO    STACKFAIL
06D7  2F7A     GOTO 0x77A
195:                   BCF     TOSL,1
06D8  10EE     BCF stackTestResult, 0x1
196:                   BTFSS   TOSL,2
06D9  1D6E     BTFSS stackTestResult, 0x2
197:                   GOTO    STACKFAIL
06DA  2F7A     GOTO 0x77A
198:                   BCF     TOSL,2
06DB  116E     BCF stackTestResult, 0x2
199:                   BTFSS   TOSL,3
06DC  1DEE     BTFSS stackTestResult, 0x3
200:                   GOTO    STACKFAIL
06DD  2F7A     GOTO 0x77A
201:                   BCF     TOSL,3
06DE  11EE     BCF stackTestResult, 0x3
202:                   BTFSS   TOSL,4
06DF  1E6E     BTFSS stackTestResult, 0x4
203:                   GOTO    STACKFAIL
06E0  2F7A     GOTO 0x77A
204:                   BCF     TOSL,4
06E1  126E     BCF stackTestResult, 0x4
205:                   BTFSS   TOSL,5
06E2  1EEE     BTFSS stackTestResult, 0x5
206:                   GOTO    STACKFAIL
06E3  2F7A     GOTO 0x77A
207:                   BCF     TOSL,5
06E4  12EE     BCF stackTestResult, 0x5
208:                   BTFSS   TOSL,6
06E5  1F6E     BTFSS stackTestResult, 0x6
209:                   GOTO    STACKFAIL
06E6  2F7A     GOTO 0x77A
210:                   BCF     TOSL,6
06E7  136E     BCF stackTestResult, 0x6
211:                   BTFSS   TOSL,7
06E8  1FEE     BTFSS stackTestResult, 0x7
212:                   GOTO    STACKFAIL
06E9  2F7A     GOTO 0x77A
213:                   BCF     TOSL,7
06EA  13EE     BCF stackTestResult, 0x7
214:                   BTFSS   TOSH,0
06EB  1C6F     BTFSS tempBSR, 0x0
215:                   GOTO    STACKFAIL
06EC  2F7A     GOTO 0x77A
216:                   BCF     TOSH,0
06ED  106F     BCF tempBSR, 0x0
217:                   BTFSS   TOSH,1
06EE  1CEF     BTFSS tempBSR, 0x1
218:                   GOTO    STACKFAIL
06EF  2F7A     GOTO 0x77A
219:                   BCF     TOSH,1
06F0  10EF     BCF tempBSR, 0x1
220:                   BTFSS   TOSH,2
06F1  1D6F     BTFSS tempBSR, 0x2
221:                   GOTO    STACKFAIL
06F2  2F7A     GOTO 0x77A
222:                   BCF     TOSH,2
06F3  116F     BCF tempBSR, 0x2
223:                   BTFSS   TOSH,3
06F4  1DEF     BTFSS tempBSR, 0x3
224:                   GOTO    STACKFAIL
06F5  2F7A     GOTO 0x77A
225:                   BCF     TOSH,3
06F6  11EF     BCF tempBSR, 0x3
226:                   BTFSS   TOSH,4
06F7  1E6F     BTFSS tempBSR, 0x4
227:                   GOTO    STACKFAIL
06F8  2F7A     GOTO 0x77A
228:                   BCF     TOSH,4
06F9  126F     BCF tempBSR, 0x4
229:                   BTFSS   TOSH,5
06FA  1EEF     BTFSS tempBSR, 0x5
230:                   GOTO    STACKFAIL
06FB  2F7A     GOTO 0x77A
231:                   BCF     TOSH,5
06FC  12EF     BCF tempBSR, 0x5
232:                   BTFSS   TOSH,6
06FD  1F6F     BTFSS tempBSR, 0x6
233:                   GOTO    STACKFAIL
06FE  2F7A     GOTO 0x77A
234:                   BCF     TOSH,6
06FF  136F     BCF tempBSR, 0x6
235:                   MOVF    STKPTR, W
0700  086D     MOVF parity, W
236:                   XORLW   0x0F
0701  3A0F     XORLW 0xF
237:                   BTFSS   STATUS, 0x02
0702  1D03     BTFSS STATUS, 0x2
238:                   GOTO    Rd1Wr0ASC
0703  2ED2     GOTO 0x6D2
239:                   
240:           //March C Minus Test will skip this section.
241:           //Read zero - descending
242:           #ifndef MARCHCMINUS
243:                   MOVLW   0x1F
244:                   MOVWF   STKPTR
245:                   Rd0NMINUS:
246:                   INCF    STKPTR
247:                   MOVLW   0x00
248:                   XORWF   TOSL
249:                   BTFSS   STATUS,2
250:                   GOTO    STACKFAIL
251:                   MOVLW   0X00
252:                   XORWF   TOSH
253:                   BTFSS   STATUS,2
254:                   GOTO    STACKFAIL
255:                   MOVF    STKPTR, W
256:                   XORLW   0x0F
257:                   BTFSS   STATUS, 0x02
258:                   GOTO    Rd0NMINUS
259:           #endif
260:           
261:           //Read zero, Write 1 - descending
262:                   MOVLW   0x10
0704  3010     MOVLW 0x10
263:                   MOVWF   STKPTR
0705  00ED     MOVWF parity
264:                   Rd0Wr1DES:
265:                   DECF    STKPTR
0706  03ED     DECF parity, F
266:                   BTFSC   TOSH,6
0707  1B6F     BTFSC tempBSR, 0x6
267:                   GOTO    STACKFAIL
0708  2F7A     GOTO 0x77A
268:                   BSF     TOSH,6
0709  176F     BSF tempBSR, 0x6
269:                   BTFSC   TOSH,5
070A  1AEF     BTFSC tempBSR, 0x5
270:                   GOTO    STACKFAIL
070B  2F7A     GOTO 0x77A
271:                   BSF     TOSH,5
070C  16EF     BSF tempBSR, 0x5
272:                   BTFSC   TOSH,4
070D  1A6F     BTFSC tempBSR, 0x4
273:                   GOTO    STACKFAIL
070E  2F7A     GOTO 0x77A
274:                   BSF     TOSH,4
070F  166F     BSF tempBSR, 0x4
275:                   BTFSC   TOSH,3
0710  19EF     BTFSC tempBSR, 0x3
276:                   GOTO    STACKFAIL
0711  2F7A     GOTO 0x77A
277:                   BSF     TOSH,3
0712  15EF     BSF tempBSR, 0x3
278:                   BTFSC   TOSH,2
0713  196F     BTFSC tempBSR, 0x2
279:                   GOTO    STACKFAIL
0714  2F7A     GOTO 0x77A
280:                   BSF     TOSH,2
0715  156F     BSF tempBSR, 0x2
281:                   BTFSC   TOSH,1
0716  18EF     BTFSC tempBSR, 0x1
282:                   GOTO    STACKFAIL
0717  2F7A     GOTO 0x77A
283:                   BSF     TOSH,1
0718  14EF     BSF tempBSR, 0x1
284:                   BTFSC   TOSH,0
0719  186F     BTFSC tempBSR, 0x0
285:                   GOTO    STACKFAIL
071A  2F7A     GOTO 0x77A
286:                   BSF     TOSH,0
071B  146F     BSF tempBSR, 0x0
287:                   BTFSC   TOSL,7
071C  1BEE     BTFSC stackTestResult, 0x7
288:                   GOTO    STACKFAIL
071D  2F7A     GOTO 0x77A
289:                   BSF     TOSL,7
071E  17EE     BSF stackTestResult, 0x7
290:                   BTFSC   TOSL,6
071F  1B6E     BTFSC stackTestResult, 0x6
291:                   GOTO    STACKFAIL
0720  2F7A     GOTO 0x77A
292:                   BSF     TOSL,6
0721  176E     BSF stackTestResult, 0x6
293:                   BTFSC   TOSL,5
0722  1AEE     BTFSC stackTestResult, 0x5
294:                   GOTO    STACKFAIL
0723  2F7A     GOTO 0x77A
295:                   BSF     TOSL,5
0724  16EE     BSF stackTestResult, 0x5
296:                   BTFSC   TOSL,4
0725  1A6E     BTFSC stackTestResult, 0x4
297:                   GOTO    STACKFAIL
0726  2F7A     GOTO 0x77A
298:                   BSF     TOSL,4
0727  166E     BSF stackTestResult, 0x4
299:                   BTFSC   TOSL,3
0728  19EE     BTFSC stackTestResult, 0x3
300:                   GOTO    STACKFAIL
0729  2F7A     GOTO 0x77A
301:                   BSF     TOSL,3
072A  15EE     BSF stackTestResult, 0x3
302:                   BTFSC   TOSL,2
072B  196E     BTFSC stackTestResult, 0x2
303:                   GOTO    STACKFAIL
072C  2F7A     GOTO 0x77A
304:                   BSF     TOSL,2
072D  156E     BSF stackTestResult, 0x2
305:                   BTFSC   TOSL,1
072E  18EE     BTFSC stackTestResult, 0x1
306:                   GOTO    STACKFAIL
072F  2F7A     GOTO 0x77A
307:                   BSF     TOSL,1
0730  14EE     BSF stackTestResult, 0x1
308:                   BTFSC   TOSL,0
0731  186E     BTFSC stackTestResult, 0x0
309:                   GOTO    STACKFAIL
0732  2F7A     GOTO 0x77A
310:                   BSF     TOSL,0
0733  146E     BSF stackTestResult, 0x0
311:                   MOVF    STKPTR, F
0734  08ED     MOVF parity, F
312:           //        XORLW   0x0F
313:                   BTFSS   STATUS, 0x02
0735  1D03     BTFSS STATUS, 0x2
314:                   GOTO    Rd0Wr1DES
0736  2F06     GOTO 0x706
315:           
316:           //Read one, Write zero - descending
317:                   MOVLW   0x10
0737  3010     MOVLW 0x10
318:                   MOVWF   STKPTR
0738  00ED     MOVWF parity
319:                   Rd1Wr0DES:
320:                   DECF    STKPTR
0739  03ED     DECF parity, F
321:                   BTFSS   TOSH,6
073A  1F6F     BTFSS tempBSR, 0x6
322:                   GOTO    STACKFAIL
073B  2F7A     GOTO 0x77A
323:                   BCF     TOSH,6
073C  136F     BCF tempBSR, 0x6
324:                   BTFSS   TOSH,5
073D  1EEF     BTFSS tempBSR, 0x5
325:                   GOTO    STACKFAIL
073E  2F7A     GOTO 0x77A
326:                   BCF     TOSH,5
073F  12EF     BCF tempBSR, 0x5
327:                   BTFSS   TOSH,4
0740  1E6F     BTFSS tempBSR, 0x4
328:                   GOTO    STACKFAIL
0741  2F7A     GOTO 0x77A
329:                   BCF     TOSH,4
0742  126F     BCF tempBSR, 0x4
330:                   BTFSS   TOSH,3
0743  1DEF     BTFSS tempBSR, 0x3
331:                   GOTO    STACKFAIL
0744  2F7A     GOTO 0x77A
332:                   BCF     TOSH,3
0745  11EF     BCF tempBSR, 0x3
333:                   BTFSS   TOSH,2
0746  1D6F     BTFSS tempBSR, 0x2
334:                   GOTO    STACKFAIL
0747  2F7A     GOTO 0x77A
335:                   BCF     TOSH,2
0748  116F     BCF tempBSR, 0x2
336:                   BTFSS   TOSH,1
0749  1CEF     BTFSS tempBSR, 0x1
337:                   GOTO    STACKFAIL
074A  2F7A     GOTO 0x77A
338:                   BCF     TOSH,1
074B  10EF     BCF tempBSR, 0x1
339:                   BTFSS   TOSH,0
074C  1C6F     BTFSS tempBSR, 0x0
340:                   GOTO    STACKFAIL
074D  2F7A     GOTO 0x77A
341:                   BCF     TOSH,0
074E  106F     BCF tempBSR, 0x0
342:                   BTFSS   TOSL,7
074F  1FEE     BTFSS stackTestResult, 0x7
343:                   GOTO    STACKFAIL
0750  2F7A     GOTO 0x77A
344:                   BCF     TOSL,7
0751  13EE     BCF stackTestResult, 0x7
345:                   BTFSS   TOSL,6
0752  1F6E     BTFSS stackTestResult, 0x6
346:                   GOTO    STACKFAIL
0753  2F7A     GOTO 0x77A
347:                   BCF     TOSL,6
0754  136E     BCF stackTestResult, 0x6
348:                   BTFSS   TOSL,5
0755  1EEE     BTFSS stackTestResult, 0x5
349:                   GOTO    STACKFAIL
0756  2F7A     GOTO 0x77A
350:                   BCF     TOSL,5
0757  12EE     BCF stackTestResult, 0x5
351:                   BTFSS   TOSL,4
0758  1E6E     BTFSS stackTestResult, 0x4
352:                   GOTO    STACKFAIL
0759  2F7A     GOTO 0x77A
353:                   BCF     TOSL,4
075A  126E     BCF stackTestResult, 0x4
354:                   BTFSS   TOSL,3
075B  1DEE     BTFSS stackTestResult, 0x3
355:                   GOTO    STACKFAIL
075C  2F7A     GOTO 0x77A
356:                   BCF     TOSL,3
075D  11EE     BCF stackTestResult, 0x3
357:                   BTFSS   TOSL,2
075E  1D6E     BTFSS stackTestResult, 0x2
358:                   GOTO    STACKFAIL
075F  2F7A     GOTO 0x77A
359:                   BCF     TOSL,2
0760  116E     BCF stackTestResult, 0x2
360:                   BTFSS   TOSL,1
0761  1CEE     BTFSS stackTestResult, 0x1
361:                   GOTO    STACKFAIL
0762  2F7A     GOTO 0x77A
362:                   BCF     TOSL,1
0763  10EE     BCF stackTestResult, 0x1
363:                   BTFSS   TOSL,0
0764  1C6E     BTFSS stackTestResult, 0x0
364:                   GOTO    STACKFAIL
0765  2F7A     GOTO 0x77A
365:                   BCF     TOSL,0
0766  106E     BCF stackTestResult, 0x0
366:                   MOVF    STKPTR, F
0767  08ED     MOVF parity, F
367:           //        XORLW   0x0F
368:                   BTFSS   STATUS, 0x02
0768  1D03     BTFSS STATUS, 0x2
369:                   GOTO    Rd1Wr0DES
0769  2F39     GOTO 0x739
370:           
371:           //Read one - ascending
372:                   MOVLW   0x1F
076A  301F     MOVLW 0x1F
373:                   MOVWF   STKPTR
076B  00ED     MOVWF parity
374:                   Rd0ASC:
375:                   INCF    STKPTR
076C  0AED     INCF parity, F
376:                   MOVLW   0x00
076D  3000     MOVLW 0x0
377:                   XORWF   TOSL
076E  06EE     XORWF stackTestResult, F
378:                   BTFSS   STATUS,2
076F  1D03     BTFSS STATUS, 0x2
379:                   GOTO    STACKFAIL
0770  2F7A     GOTO 0x77A
380:                   MOVLW   0X00
0771  3000     MOVLW 0x0
381:                   XORWF   TOSH
0772  06EF     XORWF tempBSR, F
382:                   BTFSS   STATUS,2
0773  1D03     BTFSS STATUS, 0x2
383:                   GOTO    STACKFAIL
0774  2F7A     GOTO 0x77A
384:                   MOVF    STKPTR, W
0775  086D     MOVF parity, W
385:                   XORLW   0x0F
0776  3A0F     XORLW 0xF
386:                   BTFSS   STATUS, 0x02
0777  1D03     BTFSS STATUS, 0x2
387:                   GOTO    Rd0ASC
0778  2F6C     GOTO 0x76C
388:           
389:           //The Stack test passed!
390:                   GOTO    STACKEND
0779  2F7D     GOTO 0x77D
391:           
392:           //The Stack test failed!
393:                   STACKFAIL:
394:                   BANKSEL (_stackTestResult)
077A  0020     MOVLB 0x0
395:                   movlw   0xFF
077B  30FF     MOVLW 0xFF
396:                   movwf   BANKMASK(_stackTestResult)
077C  00EE     MOVWF stackTestResult
397:                   //GOTO    STACKEND
398:           
399:                   STACKEND:
400:                   NOP
077D  0000     NOP
401:                   #endasm
402:           
403:           
404:           /*****************************************************************************
405:           * Restore Stack here.
406:           * ***************************************************************************/
407:                   CLASSB_MarchbufferAddress--;
077E  3001     MOVLW 0x1
077F  0020     MOVLB 0x0
0780  02A2     SUBWF CLASSB_MarchbufferAddress, F
0781  3000     MOVLW 0x0
0782  3BA3     SUBWFB 0x23, F
408:                   for (WREG_SHAD = 16; WREG_SHAD >= 1; WREG_SHAD--)
0783  3010     MOVLW 0x10
0784  003F     MOVLB 0x1F
0785  00E5     MOVWF InterruptsUser
0786  0865     MOVF InterruptsUser, W
0787  1903     BTFSC STATUS, 0x2
0788  2FA8     GOTO 0x7A8
07A5  003F     MOVLB 0x1F
07A6  03E5     DECF InterruptsUser, F
07A7  2F86     GOTO 0x786
409:                   {
410:                       STKPTR = WREG_SHAD - 1;
0789  0865     MOVF InterruptsUser, W
078A  3EFF     ADDLW 0xFF
078B  00ED     MOVWF parity
411:                       TOSH = *CLASSB_MarchbufferAddress;
078C  0020     MOVLB 0x0
078D  0822     MOVF CLASSB_MarchbufferAddress, W
078E  0086     MOVWF FSR1L
078F  0823     MOVF 0x23, W
0790  0087     MOVWF FSR1H
0791  0801     MOVF INDF1, W
0792  003F     MOVLB 0x1F
0793  00EF     MOVWF tempBSR
412:                       CLASSB_MarchbufferAddress--;
0794  3001     MOVLW 0x1
0795  0020     MOVLB 0x0
0796  02A2     SUBWF CLASSB_MarchbufferAddress, F
0797  3000     MOVLW 0x0
0798  3BA3     SUBWFB 0x23, F
413:                       TOSL = *CLASSB_MarchbufferAddress;
0799  0822     MOVF CLASSB_MarchbufferAddress, W
079A  0086     MOVWF FSR1L
079B  0823     MOVF 0x23, W
079C  0087     MOVWF FSR1H
079D  0801     MOVF INDF1, W
079E  003F     MOVLB 0x1F
079F  00EE     MOVWF stackTestResult
414:                       CLASSB_MarchbufferAddress--;
07A0  3001     MOVLW 0x1
07A1  0020     MOVLB 0x0
07A2  02A2     SUBWF CLASSB_MarchbufferAddress, F
07A3  3000     MOVLW 0x0
07A4  3BA3     SUBWFB 0x23, F
415:                   }
416:           
417:                   STKPTR = *CLASSB_MarchbufferAddress;
07A8  0020     MOVLB 0x0
07A9  0822     MOVF CLASSB_MarchbufferAddress, W
07AA  0086     MOVWF FSR1L
07AB  0823     MOVF 0x23, W
07AC  0087     MOVWF FSR1H
07AD  0801     MOVF INDF1, W
07AE  003F     MOVLB 0x1F
07AF  00ED     MOVWF parity
418:           
419:                   if (stackTestResult == 0xFF)
07B0  0020     MOVLB 0x0
07B1  086E     MOVF stackTestResult, W
07B2  3AFF     XORLW 0xFF
07B3  1903     BTFSC STATUS, 0x2
420:                   {
421:                       return CLASSB_TEST_FAIL;
07B4  3401     RETLW 0x1
422:                   }
423:                   else
424:                   {
425:                       return CLASSB_TEST_PASS;
07B5  3400     RETLW 0x0
426:                   }
427:           }
07B6  00AC     MOVWF 0x2C
---  C:/Users/C13819/Documents/Class_B/Class B/ClassB PIC12-16 Library Version 3.00/Microchip/Class B/CLASSB_RAMMarchBTest.c
1:             /**********************************************************************
2:             * © 2013 Microchip Technology Inc.
3:             *
4:             * Project Name:     Class B Library
5:             * FileName:         CLASSB_RAMMarchBTest.c
6:             * Dependencies:     CLASSB_RAMMarchBTest.h
7:             * Processor:        PIC16F1xxx
8:             * Compiler:         XC8
9:             * IDE:              MPLAB® IDE or MPLAB® X
10:            * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
11:            * Description:     This file contains functions to test RAM with MarchB Test.
12:            *
13:            **************************************************************************
14:             * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER: You may use this software, and
15:             * any derivatives created by any person or entity by or on your behalf,
16:             * exclusively with Microchip's products in accordance with applicable
17:             * software license terms and conditions, a copy of which is provided for
18:             * your referencein accompanying documentation. Microchip and its licensors
19:             * retain all ownership and intellectual property rights in the
20:             * accompanying software and in all derivatives hereto.
21:             *
22:             * This software and any accompanying information is for suggestion only.
23:             * It does not modify Microchip's standard warranty for its products. You
24:             * agree that you are solely responsible for testing the software and
25:             * determining its suitability. Microchip has no obligation to modify,
26:             * test, certify, or support the software.
27:             *
28:             * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:             * EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED
30:             * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:             * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE, ITS INTERACTION WITH
32:             * MICROCHIP'S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
33:             * APPLICATION.
34:             *
35:             * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY,
36:             * TORT (INCLUDING NEGLIGENCE OR BREACH OF STATUTORY DUTY), STRICT
37:             * LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT,
38:             * SPECIAL, PUNITIVE, EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE,
39:             * FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE SOFTWARE,
40:             * HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY
41:             * OR THE DAMAGES ARE FORESEEABLE. TO THE FULLEST EXTENT ALLOWABLE BY LAW,
42:             * MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
43:             * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID
44:             * DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
45:             *
46:             * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
47:             * THESE TERMS.
48:             *************************************************************************
49:            *
50:            * REVISION HISTORY:
51:            *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
52:            * Author            Date      Comments on this revision
53:            *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
54:            * CT                08/15/2008  First release of source file
55:            * Mike Cahill       11/11/2010	Updated for HI-TECH v9.80
56:            * MVL               02/22/2011	Modified for HI-TECH v9.81
57:            * Corey Simoncic    04/19/2013  Updated for XC-8
58:            *
59:            * Version       3.00
60:            *
61:            *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
62:            * ADDITIONAL NOTES:
63:            *
64:            **********************************************************************/
65:            #include "CLASSB_RAMMarchBTest.h"
66:            
67:            #ifndef MARCH_VARS
68:            #define MARCH_VARS
69:            unsigned char* CLASSB_MarchstartAddress @ 0x20;
70:            unsigned char* CLASSB_MarchbufferAddress @ 0x22;
71:            unsigned char* CLASSB_MARCHtempAddress @ 0x24;
72:            unsigned char CLASSB_MarchLength @ 0x26 = 0;
73:            #endif
74:            
75:            /******************************************************************************
76:            * Description  : This function implements the March B test. It is a complete and irredundant test
77:            * capable of detecting stuck-at faults , linked coupling Idempotent faults or Inversion Coupling
78:            * faults. This test is of complexity 17n( Where n is the number of bits).
79:            *
80:            * This test is a destructive test!!! *CLASSB_MarchbufferAddress is used as a an array to save user
81:            * memory during the test!
82:            *
83:            * Input:
84:            *     CLASSB_MarchstartAddress     :  pointer to an array declared in user memory for test
85:            *     CLASSB_MarchLength            :  value indicating the number of bytes to test
86:            *     CLASSB_MarchbufferAddress    :  pointer to location in memory where array will be stored during test
87:            * Return Values:
88:            *     CLASSB_TEST_PASS 	:  return value = 0
89:            *     CLASSB_TEST_FAIL 	:  return value = 1
90:            *                                
91:            ******************************************************************************/
92:            CLASSBRESULT CLASSB_RAMMarchBTest()
93:            {
94:                volatile unsigned char testResult;
95:            /******************************************************************************
96:             * Save memory for test in a known location designated by *CLASSB_MarchbufferAddress
97:             ******************************************************************************/
98:                if (CLASSB_MarchbufferAddress != NULL)
00AE  0823     MOVF 0x23, W
00AF  0422     IORWF CLASSB_MarchbufferAddress, W
00B0  1903     BTFSC STATUS, 0x2
00B1  28BF     GOTO 0xBF
99:                memcpy(CLASSB_MarchbufferAddress, CLASSB_MarchstartAddress, CLASSB_MarchLength);
00B2  0823     MOVF 0x23, W
00B3  00A8     MOVWF length
00B4  0822     MOVF CLASSB_MarchbufferAddress, W
00B5  00A7     MOVWF d1
00B6  0821     MOVF 0x21, W
00B7  00AA     MOVWF crcSeed
00B8  0820     MOVF CLASSB_MarchstartAddress, W
00B9  00A9     MOVWF s1
00BA  0826     MOVF CLASSB_MarchLength, W
00BB  00AB     MOVWF n
00BC  01AC     CLRF 0x2C
00BD  224D     CALL 0x24D
00BE  3180     MOVLP 0x0
100:           
101:           /******************************************************************************
102:            * Run March B Test on global RAM used by March B test.
103:            ******************************************************************************/
104:               if (CLASSB_MarchstartAddress < (char*)0x27)
00BF  3000     MOVLW 0x0
00C0  0221     SUBWF 0x21, W
00C1  3027     MOVLW 0x27
00C2  1903     BTFSC STATUS, 0x2
00C3  0220     SUBWF CLASSB_MarchstartAddress, W
00C4  1803     BTFSC STATUS, 0x0
00C5  28D6     GOTO 0xD6
105:               {
106:                   testResult = MarchBGlobalTest();
00C6  2285     CALL 0x285
00C7  3180     MOVLP 0x0
00C8  0020     MOVLB 0x0
00C9  00B3     MOVWF testResult
107:                   if (testResult)
00CA  0833     MOVF testResult, W
00CB  1D03     BTFSS STATUS, 0x2
108:                   {
109:                       return CLASSB_TEST_FAIL;
00CC  3401     RETLW 0x1
110:                   }
111:                   CLASSB_MarchLength -= (0x28 - (char)CLASSB_MarchstartAddress);
00CD  3028     MOVLW 0x28
00CE  00B2     MOVWF startAddress
00CF  0820     MOVF CLASSB_MarchstartAddress, W
00D0  02B2     SUBWF startAddress, F
00D1  0832     MOVF startAddress, W
00D2  02A6     SUBWF CLASSB_MarchLength, F
112:                   CLASSB_MarchstartAddress = (char*)0x27;
00D3  3027     MOVLW 0x27
00D4  00A0     MOVWF CLASSB_MarchstartAddress
00D5  01A1     CLRF 0x21
113:               }
114:           
115:           /******************************************************************************
116:            * Wr0 - write zero to all memory for test
117:            ******************************************************************************/
118:               CLASSB_MARCHtempAddress = CLASSB_MarchstartAddress;
00D6  0821     MOVF 0x21, W
00D7  00A5     MOVWF 0x25
00D8  0820     MOVF CLASSB_MarchstartAddress, W
00D9  00A4     MOVWF CLASSB_MARCHtempAddress
119:               for (WREG_SHAD = 0; WREG_SHAD < CLASSB_MarchLength; WREG_SHAD++)
00DA  003F     MOVLB 0x1F
00DB  01E5     CLRF InterruptsUser
00DC  0020     MOVLB 0x0
00DD  0826     MOVF CLASSB_MarchLength, W
00DE  003F     MOVLB 0x1F
00DF  0265     SUBWF InterruptsUser, W
00E0  1803     BTFSC STATUS, 0x0
00E1  28EE     GOTO 0xEE
00EB  003F     MOVLB 0x1F
00EC  0AE5     INCF InterruptsUser, F
00ED  28DC     GOTO 0xDC
120:               {
121:                   *CLASSB_MarchstartAddress=0x00;
00E2  0020     MOVLB 0x0
00E3  0820     MOVF CLASSB_MarchstartAddress, W
00E4  0086     MOVWF FSR1L
00E5  0821     MOVF 0x21, W
00E6  0087     MOVWF FSR1H
00E7  0181     CLRF INDF1
122:                   CLASSB_MarchstartAddress++;
00E8  0AA0     INCF CLASSB_MarchstartAddress, F
00E9  1903     BTFSC STATUS, 0x2
00EA  0AA1     INCF 0x21, F
123:               }
124:           #pragma warning disable 1352
125:           /******************************************************************************
126:            * Rd0Wr1Rd1Wr0Rd0Wr1 - read zero, write one, read 1, write zero, read 0, write 1
127:            ******************************************************************************/
128:               CLASSB_MarchstartAddress = CLASSB_MARCHtempAddress;
00EE  0020     MOVLB 0x0
00EF  0825     MOVF 0x25, W
00F0  00A1     MOVWF 0x21
00F1  0824     MOVF CLASSB_MARCHtempAddress, W
00F2  00A0     MOVWF CLASSB_MarchstartAddress
129:               for (WREG_SHAD = 0; WREG_SHAD < CLASSB_MarchLength; WREG_SHAD++)
00F3  003F     MOVLB 0x1F
00F4  01E5     CLRF InterruptsUser
00F5  0020     MOVLB 0x0
00F6  0826     MOVF CLASSB_MarchLength, W
00F7  003F     MOVLB 0x1F
00F8  0265     SUBWF InterruptsUser, W
00F9  1803     BTFSC STATUS, 0x0
00FA  292E     GOTO 0x12E
012B  003F     MOVLB 0x1F
012C  0AE5     INCF InterruptsUser, F
012D  28F5     GOTO 0xF5
130:               {        
131:                   FSR0H_SHAD = 0x00;
00FB  01E9     CLRF Timer1GateUser
132:                   for (FSR0L_SHAD=0; FSR0L_SHAD<8; FSR0L_SHAD++)
00FC  01E8     CLRF PIR1User
00FD  3008     MOVLW 0x8
00FE  0268     SUBWF PIR1User, W
00FF  1803     BTFSC STATUS, 0x0
0100  2927     GOTO 0x127
0125  0AE8     INCF PIR1User, F
0126  28FD     GOTO 0xFD
133:                   {
134:                       #asm
135:                       MOVLB   0x00
0101  0020     MOVLB 0x0
136:                       MOVF    BANKMASK(_CLASSB_MarchstartAddress), W
0102  0820     MOVF CLASSB_MarchstartAddress, W
137:                       MOVWF   FSR1L
0103  0086     MOVWF FSR1L
138:                       MOVF    INDF1, W
0104  0801     MOVF INDF1, W
139:                       MOVLB   0x1F
0105  003F     MOVLB 0x1F
140:                       XORWF   FSR0H_SHAD, W
0106  0669     XORWF Timer1GateUser, W
141:                       MOVLW   0x01
0107  3001     MOVLW 0x1
142:                       BTFSS   STATUS, 0x02        //read zero
0108  1D03     BTFSS STATUS, 0x2
143:                       MOVWF   FSR1L_SHAD
0109  00EA     MOVWF Timer1User
144:           
145:                       MOVF    INDF1, W
010A  0801     MOVF INDF1, W
146:                       BSF     STATUS, 0x00
010B  1403     BSF STATUS, 0x0
147:                       RLF     FSR0H_SHAD, F
010C  0DE9     RLF Timer1GateUser, F
148:                       IORWF   FSR0H_SHAD, W
010D  0469     IORWF Timer1GateUser, W
149:                       MOVWF   INDF1               //write one
010E  0081     MOVWF INDF1
150:           
151:                       MOVF    INDF1, W
010F  0801     MOVF INDF1, W
152:                       XORWF   FSR0H_SHAD, W       //read one
0110  0669     XORWF Timer1GateUser, W
153:                       MOVLW   0x01
0111  3001     MOVLW 0x1
154:                       BTFSS   STATUS, 0x02
0112  1D03     BTFSS STATUS, 0x2
155:                       MOVWF   FSR1L_SHAD
0113  00EA     MOVWF Timer1User
156:           
157:                       MOVF    INDF1, W
158:                       LSRF    FSR0H_SHAD, W
0114  3669     LSRF Timer1GateUser, W
159:                       LSRF    FSR0H_SHAD, F
0115  36E9     LSRF Timer1GateUser, F
160:                       MOVWF   INDF1               //write zero
0116  0081     MOVWF INDF1
161:           
162:                       MOVF    INDF1, W
0117  0801     MOVF INDF1, W
163:                       XORWF   FSR0H_SHAD, W
0118  0669     XORWF Timer1GateUser, W
164:                       MOVLW   0X01
0119  3001     MOVLW 0x1
165:                       BTFSS   STATUS, 0X02        //read zero
011A  1D03     BTFSS STATUS, 0x2
166:                       MOVWF   FSR1L_SHAD
011B  00EA     MOVWF Timer1User
167:           
168:                       MOVF   INDF1, W
011C  0801     MOVF INDF1, W
169:                       BSF     STATUS, 0X00
011D  1403     BSF STATUS, 0x0
170:                       RLF     FSR0H_SHAD, F
011E  0DE9     RLF Timer1GateUser, F
171:                       IORWF   FSR0H_SHAD, W
011F  0469     IORWF Timer1GateUser, W
172:                       MOVWF   INDF1               //write one
0120  0081     MOVWF INDF1
173:                       #endasm
174:                       if(FSR1L_SHAD)
0121  003F     MOVLB 0x1F
0122  086A     MOVF Timer1User, W
0123  1D03     BTFSS STATUS, 0x2
0124  3401     RETLW 0x1
175:                           return CLASSB_TEST_FAIL;
176:                   }
177:                   CLASSB_MarchstartAddress++;
0127  0020     MOVLB 0x0
0128  0AA0     INCF CLASSB_MarchstartAddress, F
0129  1903     BTFSC STATUS, 0x2
012A  0AA1     INCF 0x21, F
178:               }
179:           
180:           /******************************************************************************
181:            * Rd1Wr0Wr1 - read one, write zero, write one
182:            ******************************************************************************/
183:               CLASSB_MarchstartAddress = CLASSB_MARCHtempAddress;
012E  0020     MOVLB 0x0
012F  0825     MOVF 0x25, W
0130  00A1     MOVWF 0x21
0131  0824     MOVF CLASSB_MARCHtempAddress, W
0132  00A0     MOVWF CLASSB_MarchstartAddress
184:               for (WREG_SHAD = 0; WREG_SHAD < CLASSB_MarchLength; WREG_SHAD++)
0133  003F     MOVLB 0x1F
0134  01E5     CLRF InterruptsUser
0135  0020     MOVLB 0x0
0136  0826     MOVF CLASSB_MarchLength, W
0137  003F     MOVLB 0x1F
0138  0265     SUBWF InterruptsUser, W
0139  1803     BTFSC STATUS, 0x0
013A  2960     GOTO 0x160
015D  003F     MOVLB 0x1F
015E  0AE5     INCF InterruptsUser, F
015F  2935     GOTO 0x135
185:               {
186:                   FSR0H_SHAD = 0xFF;
013B  30FF     MOVLW 0xFF
013C  00E9     MOVWF Timer1GateUser
187:                   FSR1H_SHAD = 0XFE;
013D  30FE     MOVLW 0xFE
013E  00EB     MOVWF dataXorCrcHigh
188:                   for (FSR0L_SHAD=0; FSR0L_SHAD<8; FSR0L_SHAD++)
013F  01E8     CLRF PIR1User
0140  3008     MOVLW 0x8
0141  0268     SUBWF PIR1User, W
0142  1803     BTFSC STATUS, 0x0
0143  2959     GOTO 0x159
0157  0AE8     INCF PIR1User, F
0158  2940     GOTO 0x140
189:                   {
190:                       #asm
191:                       MOVLB   0x00;
0144  0020     MOVLB 0x0
192:                       MOVF    BANKMASK(_CLASSB_MarchstartAddress), W
0145  0820     MOVF CLASSB_MarchstartAddress, W
193:                       MOVWF   FSR1L
0146  0086     MOVWF FSR1L
194:                       MOVF    INDF1, W
0147  0801     MOVF INDF1, W
195:                       MOVLB   0x1F
0148  003F     MOVLB 0x1F
196:                       XORWF   FSR0H_SHAD, W       //read one
0149  0669     XORWF Timer1GateUser, W
197:                       MOVLW   0x01
014A  3001     MOVLW 0x1
198:                       BTFSS   STATUS, 0x02
014B  1D03     BTFSS STATUS, 0x2
199:                       MOVWF   FSR1L_SHAD
014C  00EA     MOVWF Timer1User
200:           
201:                       MOVF    FSR1H_SHAD, W
014D  086B     MOVF dataXorCrcHigh, W
202:                       MOVWF   INDF1               //write zero
014E  0081     MOVWF INDF1
203:                       BSF     STATUS, 0x00
014F  1403     BSF STATUS, 0x0
204:                       RLF     FSR1H_SHAD, F
0150  0DEB     RLF dataXorCrcHigh, F
205:           
206:                       MOVF    FSR0H_SHAD, W
0151  0869     MOVF Timer1GateUser, W
207:                       MOVWF   INDF1               //write one
0152  0081     MOVWF INDF1
208:                       #endasm
209:                       if(FSR1L_SHAD)
0153  003F     MOVLB 0x1F
0154  086A     MOVF Timer1User, W
0155  1D03     BTFSS STATUS, 0x2
0156  3401     RETLW 0x1
210:                           return CLASSB_TEST_FAIL;
211:                   }
212:                   CLASSB_MarchstartAddress++;
0159  0020     MOVLB 0x0
015A  0AA0     INCF CLASSB_MarchstartAddress, F
015B  1903     BTFSC STATUS, 0x2
015C  0AA1     INCF 0x21, F
213:               }
214:           
215:           /******************************************************************************
216:            * Rd1Wr0Wr1Wr0 - read one, write zero, write one, write zero
217:            ******************************************************************************/
218:               //CLASSB_MarchstartAddress = CLASSB_MARCHtempAddress + CLASSB_MarchLength - 1;
219:               CLASSB_MarchstartAddress--;
0160  3001     MOVLW 0x1
0161  0020     MOVLB 0x0
0162  02A0     SUBWF CLASSB_MarchstartAddress, F
0163  3000     MOVLW 0x0
0164  3BA1     SUBWFB 0x21, F
220:               CLASSB_MARCHtempAddress = CLASSB_MarchstartAddress;
0165  0821     MOVF 0x21, W
0166  00A5     MOVWF 0x25
0167  0820     MOVF CLASSB_MarchstartAddress, W
0168  00A4     MOVWF CLASSB_MARCHtempAddress
221:               for (WREG_SHAD = CLASSB_MarchLength; WREG_SHAD > 0; WREG_SHAD--)
0169  0826     MOVF CLASSB_MarchLength, W
016A  003F     MOVLB 0x1F
016B  00E5     MOVWF InterruptsUser
016C  0865     MOVF InterruptsUser, W
016D  1903     BTFSC STATUS, 0x2
016E  2997     GOTO 0x197
0194  003F     MOVLB 0x1F
0195  03E5     DECF InterruptsUser, F
0196  296C     GOTO 0x16C
222:               {
223:                   FSR0H_SHAD = 0xFF;
016F  30FF     MOVLW 0xFF
0170  00E9     MOVWF Timer1GateUser
224:                   FSR1H_SHAD = 0X7F;
0171  307F     MOVLW 0x7F
0172  00EB     MOVWF dataXorCrcHigh
225:                   for (FSR0L_SHAD=0; FSR0L_SHAD<8; FSR0L_SHAD++)
0173  01E8     CLRF PIR1User
0174  3008     MOVLW 0x8
0175  0268     SUBWF PIR1User, W
0176  1803     BTFSC STATUS, 0x0
0177  298F     GOTO 0x18F
018D  0AE8     INCF PIR1User, F
018E  2974     GOTO 0x174
226:                   {
227:                       #asm
228:                       MOVLB   0x00;
0178  0020     MOVLB 0x0
229:                       MOVF    BANKMASK(_CLASSB_MarchstartAddress), W
0179  0820     MOVF CLASSB_MarchstartAddress, W
230:                       MOVWF   FSR1L
017A  0086     MOVWF FSR1L
231:                       MOVF    INDF1, W
017B  0801     MOVF INDF1, W
232:                       MOVLB   0x1F
017C  003F     MOVLB 0x1F
233:                       XORWF   FSR0H_SHAD, W       //read one
017D  0669     XORWF Timer1GateUser, W
234:                       MOVLW   0x01
017E  3001     MOVLW 0x1
235:                       BTFSS   STATUS, 0x02
017F  1D03     BTFSS STATUS, 0x2
236:                       MOVWF   FSR1L_SHAD
0180  00EA     MOVWF Timer1User
237:           
238:                       MOVF    FSR1H_SHAD, W
0181  086B     MOVF dataXorCrcHigh, W
239:                       MOVWF   INDF1               //write zero
0182  0081     MOVWF INDF1
240:           
241:           
242:                       MOVF    FSR0H_SHAD, W
0183  0869     MOVF Timer1GateUser, W
243:                       MOVWF   INDF1               //write one
0184  0081     MOVWF INDF1
244:                               
245:                       MOVF    FSR1H_SHAD, W
0185  086B     MOVF dataXorCrcHigh, W
246:                       MOVWF   INDF1               //write zero
0186  0081     MOVWF INDF1
247:                               
248:                       LSRF    FSR1H_SHAD, F
0187  36EB     LSRF dataXorCrcHigh, F
249:                       LSRF    FSR0H_SHAD, F
0188  36E9     LSRF Timer1GateUser, F
250:                       #endasm
251:                       if(FSR1L_SHAD)
0189  003F     MOVLB 0x1F
018A  086A     MOVF Timer1User, W
018B  1D03     BTFSS STATUS, 0x2
018C  3401     RETLW 0x1
252:                           return CLASSB_TEST_FAIL;
253:                   }
254:                   CLASSB_MarchstartAddress--;
018F  3001     MOVLW 0x1
0190  0020     MOVLB 0x0
0191  02A0     SUBWF CLASSB_MarchstartAddress, F
0192  3000     MOVLW 0x0
0193  3BA1     SUBWFB 0x21, F
255:               }
256:           
257:           /******************************************************************************
258:            * Rd0Wr1Wr0 - read zero, write one, write zero
259:            ******************************************************************************/
260:               CLASSB_MarchstartAddress = CLASSB_MARCHtempAddress;
0197  0020     MOVLB 0x0
0198  0825     MOVF 0x25, W
0199  00A1     MOVWF 0x21
019A  0824     MOVF CLASSB_MARCHtempAddress, W
019B  00A0     MOVWF CLASSB_MarchstartAddress
261:               for (WREG_SHAD = CLASSB_MarchLength; WREG_SHAD > 0; WREG_SHAD--)
019C  0826     MOVF CLASSB_MarchLength, W
019D  003F     MOVLB 0x1F
019E  00E5     MOVWF InterruptsUser
019F  0865     MOVF InterruptsUser, W
01A0  1903     BTFSC STATUS, 0x2
01A1  29C6     GOTO 0x1C6
01C3  003F     MOVLB 0x1F
01C4  03E5     DECF InterruptsUser, F
01C5  299F     GOTO 0x19F
262:               {
263:                   FSR0H_SHAD = 0x00;
01A2  01E9     CLRF Timer1GateUser
264:                   FSR1H_SHAD = 0x80;
01A3  3080     MOVLW 0x80
01A4  00EB     MOVWF dataXorCrcHigh
265:                   for (FSR0L_SHAD=0; FSR0L_SHAD<8; FSR0L_SHAD++)
01A5  01E8     CLRF PIR1User
01A6  3008     MOVLW 0x8
01A7  0268     SUBWF PIR1User, W
01A8  1803     BTFSC STATUS, 0x0
01A9  29BE     GOTO 0x1BE
01BC  0AE8     INCF PIR1User, F
01BD  29A6     GOTO 0x1A6
266:                   {
267:                       #asm
268:                       MOVLB   0x00
01AA  0020     MOVLB 0x0
269:                       MOVF    BANKMASK(_CLASSB_MarchstartAddress), W
01AB  0820     MOVF CLASSB_MarchstartAddress, W
270:                       MOVWF   FSR1L
01AC  0086     MOVWF FSR1L
271:                       MOVF    INDF1, W
01AD  0801     MOVF INDF1, W
272:                       MOVLB   0x1F
01AE  003F     MOVLB 0x1F
273:                       XORWF   FSR0H_SHAD, W
01AF  0669     XORWF Timer1GateUser, W
274:                       MOVLW   0x01
01B0  3001     MOVLW 0x1
275:                       BTFSS   STATUS, 0x02        //read zero
01B1  1D03     BTFSS STATUS, 0x2
276:                       MOVWF   FSR1L_SHAD
01B2  00EA     MOVWF Timer1User
277:           
278:                       MOVF    FSR1H_SHAD, W
01B3  086B     MOVF dataXorCrcHigh, W
279:                       MOVWF   INDF1               //write one
01B4  0081     MOVWF INDF1
280:                       LSRF    FSR1H_SHAD, F
01B5  36EB     LSRF dataXorCrcHigh, F
281:           
282:                       MOVF    FSR0H_SHAD, W
01B6  0869     MOVF Timer1GateUser, W
283:                       MOVWF   INDF1               //write zero
01B7  0081     MOVWF INDF1
284:                       #endasm
285:                       if(FSR1L_SHAD)
01B8  003F     MOVLB 0x1F
01B9  086A     MOVF Timer1User, W
01BA  1D03     BTFSS STATUS, 0x2
01BB  3401     RETLW 0x1
286:                           return CLASSB_TEST_FAIL;
287:                   }
288:                   CLASSB_MarchstartAddress--;
01BE  3001     MOVLW 0x1
01BF  0020     MOVLB 0x0
01C0  02A0     SUBWF CLASSB_MarchstartAddress, F
01C1  3000     MOVLW 0x0
01C2  3BA1     SUBWFB 0x21, F
289:               }
290:               CLASSB_MarchstartAddress++;
01C6  0020     MOVLB 0x0
01C7  0AA0     INCF CLASSB_MarchstartAddress, F
01C8  1903     BTFSC STATUS, 0x2
01C9  0AA1     INCF 0x21, F
291:           
292:           /******************************************************************************
293:            * Restore user memory
294:            * All tests passed
295:            ******************************************************************************/
296:               if (CLASSB_MarchbufferAddress != NULL)
01CA  0823     MOVF 0x23, W
01CB  0422     IORWF CLASSB_MarchbufferAddress, W
01CC  1903     BTFSC STATUS, 0x2
01CD  3400     RETLW 0x0
297:               memcpy(CLASSB_MarchstartAddress, CLASSB_MarchbufferAddress, CLASSB_MarchLength); //restore user memory
01CE  0821     MOVF 0x21, W
01CF  00A8     MOVWF length
01D0  0820     MOVF CLASSB_MarchstartAddress, W
01D1  00A7     MOVWF d1
01D2  0823     MOVF 0x23, W
01D3  00AA     MOVWF crcSeed
01D4  0822     MOVF CLASSB_MarchbufferAddress, W
01D5  00A9     MOVWF s1
01D6  0826     MOVF CLASSB_MarchLength, W
01D7  00AB     MOVWF n
01D8  01AC     CLRF 0x2C
01D9  224D     CALL 0x24D
298:           
299:               return CLASSB_TEST_PASS;
01DA  3400     RETLW 0x0
300:           }
01DB  30AA     MOVLW 0xAA
301:           
302:           /******************************************************************************
303:           * Description:
304:           *     This function tests the global variables used in the March Test
305:           * Return Values:
306:           *     CLASSB_TEST_PASS :  return value = 0
307:           *     CLASSB_TEST_FAIL :  return value = 1
308:           *
309:           ******************************************************************************/
310:           CLASSBRESULT MarchBGlobalTest()
311:           {
312:               uint8_t* tempAddrPTR;
313:               uint8_t r;
314:               //uint8_t globalResult;
315:               uint8_t bitMask;
316:               uint8_t i;
317:           
318:           
319:           #asm
320:               MOVLB 0x00
0285  0020     MOVLB 0x0
321:               MOVF 0x20, W
0286  0820     MOVF CLASSB_MarchstartAddress, W
322:               MOVWF FSR0L         //CLASSB_MarchstartAddress
0287  0084     MOVWF FSR0L
323:               MOVF 0x22, W
0288  0822     MOVF CLASSB_MarchbufferAddress, W
324:               MOVWF FSR0H         //CLASSB_MarchbufferAddress
0289  0085     MOVWF FSR0H
325:               MOVF 0x26, W
028A  0826     MOVF CLASSB_MarchLength, W
326:               MOVLB 0x1F
028B  003F     MOVLB 0x1F
327:               MOVWF WREG_SHAD     //CLASSB_MarchLength
028C  00E5     MOVWF InterruptsUser
328:               MOVF FSR0L, W
028D  0804     MOVF FSR0L, W
329:               MOVWF FSR0L_SHAD    //CLASSB_MarchstartAddress
028E  00E8     MOVWF PIR1User
330:               MOVF FSR0H, W
028F  0805     MOVF FSR0H, W
331:               MOVWF FSR0H_SHAD    //CLASSB_MarchbufferAddress
0290  00E9     MOVWF Timer1GateUser
332:           #endasm
333:              
334:               tempAddrPTR = (char*)0x20;
0291  3020     MOVLW 0x20
0292  0020     MOVLB 0x0
0293  00AB     MOVWF n
0294  01AC     CLRF 0x2C
335:               
336:               //(^w0)(^r0,w1,r1,w0,r0,w1)(^r1,w0,w1)
337:               //(/r1,w0,w1,w0)(/r0,w1,w0)
338:           
339:               //write 0 - ascending
340:               for(r = 0; r < 7; r++)
0295  01A9     CLRF s1
029E  3007     MOVLW 0x7
029F  0AA9     INCF s1, F
02A0  0229     SUBWF s1, W
02A1  1C03     BTFSS STATUS, 0x0
02A2  2A96     GOTO 0x296
341:               {
342:                   *tempAddrPTR = 0;
0296  082B     MOVF n, W
0297  0086     MOVWF FSR1L
0298  082C     MOVF 0x2C, W
0299  0087     MOVWF FSR1H
029A  0181     CLRF INDF1
343:                   tempAddrPTR++;
029B  0AAB     INCF n, F
029C  1903     BTFSC STATUS, 0x2
029D  0AAC     INCF 0x2C, F
344:               }
345:           
346:               //read 0, write 1, read 1, write 0, read 0, write 1 - ascending
347:               tempAddrPTR = (char*)0x20;
02A3  3020     MOVLW 0x20
02A4  00AB     MOVWF n
02A5  01AC     CLRF 0x2C
348:               for(r = 0; r < 7; r++)
02A6  01A9     CLRF s1
02F2  3007     MOVLW 0x7
02F3  0AA9     INCF s1, F
02F4  0229     SUBWF s1, W
02F5  1C03     BTFSS STATUS, 0x0
02F6  2AA7     GOTO 0x2A7
349:               {
350:                   bitMask = 0x01;
02A7  01AA     CLRF crcSeed
02A8  0AAA     INCF crcSeed, F
351:                   for (i = 0; i < 8; i++)
02A9  01A8     CLRF length
02E9  3008     MOVLW 0x8
02EB  0AA8     INCF length, F
02EC  0228     SUBWF length, W
02ED  1C03     BTFSS STATUS, 0x0
02EE  2AAA     GOTO 0x2AA
352:                   {
353:                       if (*tempAddrPTR & bitMask) //read zero
02AA  082B     MOVF n, W
02AB  0086     MOVWF FSR1L
02AC  082C     MOVF 0x2C, W
02AD  0087     MOVWF FSR1H
02AE  0801     MOVF INDF1, W
02AF  052A     ANDWF crcSeed, W
02B0  1D03     BTFSS STATUS, 0x2
354:                       {
355:                           return CLASSB_TEST_FAIL;
02B1  3401     RETLW 0x1
356:                       }
357:                       else
358:                       {
359:                           *tempAddrPTR = *tempAddrPTR | bitMask; //write one
02B2  082B     MOVF n, W
02B3  0086     MOVWF FSR1L
02B4  082C     MOVF 0x2C, W
02B5  0087     MOVWF FSR1H
02B6  0801     MOVF INDF1, W
02B7  042A     IORWF crcSeed, W
02B8  00A7     MOVWF d1
02B9  082B     MOVF n, W
02BA  0086     MOVWF FSR1L
02BB  082C     MOVF 0x2C, W
02BC  0087     MOVWF FSR1H
02BD  0827     MOVF d1, W
02BE  0081     MOVWF INDF1
360:                       }
361:                       if(*tempAddrPTR & bitMask) //read one
02BF  082B     MOVF n, W
02C0  0086     MOVWF FSR1L
02C1  082C     MOVF 0x2C, W
02C2  0087     MOVWF FSR1H
02C3  0801     MOVF INDF1, W
02C4  052A     ANDWF crcSeed, W
02C5  1903     BTFSC STATUS, 0x2
02C6  3401     RETLW 0x1
362:                       {
363:                           *tempAddrPTR = *tempAddrPTR & ~bitMask; //write zero
02C7  082B     MOVF n, W
02C8  0086     MOVWF FSR1L
02C9  082C     MOVF 0x2C, W
02CA  0087     MOVWF FSR1H
02CB  092A     COMF crcSeed, W
02CC  0501     ANDWF INDF1, W
02CD  00A7     MOVWF d1
02CE  082B     MOVF n, W
02CF  0086     MOVWF FSR1L
02D0  082C     MOVF 0x2C, W
02D1  0087     MOVWF FSR1H
02D2  0827     MOVF d1, W
02D3  0081     MOVWF INDF1
364:                       }
365:                       else
366:                       {
367:                           return CLASSB_TEST_FAIL;
368:                       }
369:                       if(*tempAddrPTR & bitMask) //read zero
02D4  082B     MOVF n, W
02D5  0086     MOVWF FSR1L
02D6  082C     MOVF 0x2C, W
02D7  0087     MOVWF FSR1H
02D8  0801     MOVF INDF1, W
02D9  052A     ANDWF crcSeed, W
02DA  1D03     BTFSS STATUS, 0x2
02DB  3401     RETLW 0x1
370:                       {
371:                           return CLASSB_TEST_FAIL;
372:                       }
373:                       else
374:                       {
375:                           *tempAddrPTR = *tempAddrPTR | bitMask; //write one
02DC  082B     MOVF n, W
02DD  0086     MOVWF FSR1L
02DE  082C     MOVF 0x2C, W
02DF  0087     MOVWF FSR1H
02E0  0801     MOVF INDF1, W
02E1  042A     IORWF crcSeed, W
02E2  00A7     MOVWF d1
02E3  082B     MOVF n, W
02E4  0086     MOVWF FSR1L
02E5  082C     MOVF 0x2C, W
02E6  0087     MOVWF FSR1H
02E7  0827     MOVF d1, W
02E8  0081     MOVWF INDF1
376:                       }
377:                       bitMask <<= 1;
02EA  35AA     LSLF crcSeed, F
378:                   }
379:                   tempAddrPTR++;
02EF  0AAB     INCF n, F
02F0  1903     BTFSC STATUS, 0x2
02F1  0AAC     INCF 0x2C, F
380:               }
381:           
382:               //read 1, write 0, write 1 - ascending
383:               tempAddrPTR = (char*)0x20;
02F7  3020     MOVLW 0x20
02F8  00AB     MOVWF n
02F9  01AC     CLRF 0x2C
384:               for(r = 0; r < 7; r++)
02FA  01A9     CLRF s1
0329  3007     MOVLW 0x7
032A  0AA9     INCF s1, F
032B  0229     SUBWF s1, W
032C  1C03     BTFSS STATUS, 0x0
032D  2AFB     GOTO 0x2FB
385:               {
386:                   bitMask = 0x01;
02FB  01AA     CLRF crcSeed
02FC  0AAA     INCF crcSeed, F
387:                   for (i=0; i<8; i++)
02FD  01A8     CLRF length
0320  3008     MOVLW 0x8
0322  0AA8     INCF length, F
0323  0228     SUBWF length, W
0324  1C03     BTFSS STATUS, 0x0
0325  2AFE     GOTO 0x2FE
388:                   {
389:                       if (*tempAddrPTR & bitMask)
02FE  082B     MOVF n, W
02FF  0086     MOVWF FSR1L
0300  082C     MOVF 0x2C, W
0301  0087     MOVWF FSR1H
0302  0801     MOVF INDF1, W
0303  052A     ANDWF crcSeed, W
0304  1903     BTFSC STATUS, 0x2
0305  3401     RETLW 0x1
390:                       {
391:                           *tempAddrPTR = *tempAddrPTR & ~bitMask;
0306  082B     MOVF n, W
0307  0086     MOVWF FSR1L
0308  082C     MOVF 0x2C, W
0309  0087     MOVWF FSR1H
030A  092A     COMF crcSeed, W
030B  0501     ANDWF INDF1, W
030C  00A7     MOVWF d1
030D  082B     MOVF n, W
030E  0086     MOVWF FSR1L
030F  082C     MOVF 0x2C, W
0310  0087     MOVWF FSR1H
0311  0827     MOVF d1, W
0312  0081     MOVWF INDF1
392:                           *tempAddrPTR = *tempAddrPTR | bitMask;
0313  082B     MOVF n, W
0314  0086     MOVWF FSR1L
0315  082C     MOVF 0x2C, W
0316  0087     MOVWF FSR1H
0317  0801     MOVF INDF1, W
0318  042A     IORWF crcSeed, W
0319  00A7     MOVWF d1
031A  082B     MOVF n, W
031B  0086     MOVWF FSR1L
031C  082C     MOVF 0x2C, W
031D  0087     MOVWF FSR1H
031E  0827     MOVF d1, W
031F  0081     MOVWF INDF1
393:                       }
394:                       else
395:                       {
396:                           return CLASSB_TEST_FAIL;
397:                       }
398:                       bitMask<<=1;
0321  35AA     LSLF crcSeed, F
399:                   }
400:                   tempAddrPTR++;
0326  0AAB     INCF n, F
0327  1903     BTFSC STATUS, 0x2
0328  0AAC     INCF 0x2C, F
401:               }
402:           
403:               //read 1, write 0, write 1, write 0 - descending
404:               tempAddrPTR = (char*)0x26;
032E  3026     MOVLW 0x26
032F  00AB     MOVWF n
0330  01AC     CLRF 0x2C
405:               for (r = 0; r < 7; r++)
0331  01A9     CLRF s1
036E  3007     MOVLW 0x7
036F  0AA9     INCF s1, F
0370  0229     SUBWF s1, W
0371  1C03     BTFSS STATUS, 0x0
0372  2B32     GOTO 0x332
406:               {
407:                   bitMask = 0x80;
0332  3080     MOVLW 0x80
0333  00AA     MOVWF crcSeed
408:                   for (i=0; i<8; i++)
0334  01A8     CLRF length
0364  3008     MOVLW 0x8
0366  0AA8     INCF length, F
0367  0228     SUBWF length, W
0368  1C03     BTFSS STATUS, 0x0
0369  2B35     GOTO 0x335
409:                   {
410:                       if (*tempAddrPTR & bitMask)
0335  082B     MOVF n, W
0336  0086     MOVWF FSR1L
0337  082C     MOVF 0x2C, W
0338  0087     MOVWF FSR1H
0339  0801     MOVF INDF1, W
033A  052A     ANDWF crcSeed, W
033B  1903     BTFSC STATUS, 0x2
033C  3401     RETLW 0x1
411:                       {
412:                           *tempAddrPTR = *tempAddrPTR & ~bitMask;
033D  082B     MOVF n, W
033E  0086     MOVWF FSR1L
033F  082C     MOVF 0x2C, W
0340  0087     MOVWF FSR1H
0341  092A     COMF crcSeed, W
0342  0501     ANDWF INDF1, W
0343  00A7     MOVWF d1
0344  082B     MOVF n, W
0345  0086     MOVWF FSR1L
0346  082C     MOVF 0x2C, W
0347  0087     MOVWF FSR1H
0348  0827     MOVF d1, W
0349  0081     MOVWF INDF1
413:                           *tempAddrPTR = *tempAddrPTR | bitMask;
034A  082B     MOVF n, W
034B  0086     MOVWF FSR1L
034C  082C     MOVF 0x2C, W
034D  0087     MOVWF FSR1H
034E  0801     MOVF INDF1, W
034F  042A     IORWF crcSeed, W
0350  00A7     MOVWF d1
0351  082B     MOVF n, W
0352  0086     MOVWF FSR1L
0353  082C     MOVF 0x2C, W
0354  0087     MOVWF FSR1H
0355  0827     MOVF d1, W
0356  0081     MOVWF INDF1
414:                           *tempAddrPTR = *tempAddrPTR & ~bitMask;
0357  082B     MOVF n, W
0358  0086     MOVWF FSR1L
0359  082C     MOVF 0x2C, W
035A  0087     MOVWF FSR1H
035B  092A     COMF crcSeed, W
035C  0501     ANDWF INDF1, W
035D  00A7     MOVWF d1
035E  082B     MOVF n, W
035F  0086     MOVWF FSR1L
0360  082C     MOVF 0x2C, W
0361  0087     MOVWF FSR1H
0362  0827     MOVF d1, W
0363  0081     MOVWF INDF1
415:                       }
416:                       else
417:                       {
418:                           return CLASSB_TEST_FAIL;
419:                       }
420:                       bitMask>>=1;
0365  36AA     LSRF crcSeed, F
421:                   }
422:                   tempAddrPTR--;
036A  3001     MOVLW 0x1
036B  02AB     SUBWF n, F
036C  3000     MOVLW 0x0
036D  3BAC     SUBWFB 0x2C, F
423:               }
424:           
425:               //read 0, write 1, write 0 - descending
426:               tempAddrPTR = (char*)0x26;
0373  3026     MOVLW 0x26
0374  00AB     MOVWF n
0375  01AC     CLRF 0x2C
427:               for (r = 0; r < 7; r++)
0376  01A9     CLRF s1
03A6  3007     MOVLW 0x7
03A7  0AA9     INCF s1, F
03A8  0229     SUBWF s1, W
03A9  1C03     BTFSS STATUS, 0x0
03AA  2B77     GOTO 0x377
428:               {
429:                   bitMask = 0x80;
0377  3080     MOVLW 0x80
0378  00AA     MOVWF crcSeed
430:                   for (i=0; i<8; i++)
0379  01A8     CLRF length
039C  3008     MOVLW 0x8
039E  0AA8     INCF length, F
039F  0228     SUBWF length, W
03A0  1C03     BTFSS STATUS, 0x0
03A1  2B7A     GOTO 0x37A
431:                   {
432:                       if (*tempAddrPTR & bitMask)
037A  082B     MOVF n, W
037B  0086     MOVWF FSR1L
037C  082C     MOVF 0x2C, W
037D  0087     MOVWF FSR1H
037E  0801     MOVF INDF1, W
037F  052A     ANDWF crcSeed, W
0380  1D03     BTFSS STATUS, 0x2
0381  3401     RETLW 0x1
433:                           return CLASSB_TEST_FAIL;
434:                       else
435:                       {
436:                           *tempAddrPTR = *tempAddrPTR | bitMask;
0382  082B     MOVF n, W
0383  0086     MOVWF FSR1L
0384  082C     MOVF 0x2C, W
0385  0087     MOVWF FSR1H
0386  0801     MOVF INDF1, W
0387  042A     IORWF crcSeed, W
0388  00A7     MOVWF d1
0389  082B     MOVF n, W
038A  0086     MOVWF FSR1L
038B  082C     MOVF 0x2C, W
038C  0087     MOVWF FSR1H
038D  0827     MOVF d1, W
038E  0081     MOVWF INDF1
437:                           *tempAddrPTR = *tempAddrPTR & ~bitMask;
038F  082B     MOVF n, W
0390  0086     MOVWF FSR1L
0391  082C     MOVF 0x2C, W
0392  0087     MOVWF FSR1H
0393  092A     COMF crcSeed, W
0394  0501     ANDWF INDF1, W
0395  00A7     MOVWF d1
0396  082B     MOVF n, W
0397  0086     MOVWF FSR1L
0398  082C     MOVF 0x2C, W
0399  0087     MOVWF FSR1H
039A  0827     MOVF d1, W
039B  0081     MOVWF INDF1
438:                       }
439:                       bitMask>>=1;
039D  36AA     LSRF crcSeed, F
440:                   }
441:                   tempAddrPTR--;
03A2  3001     MOVLW 0x1
03A3  02AB     SUBWF n, F
03A4  3000     MOVLW 0x0
03A5  3BAC     SUBWFB 0x2C, F
442:               }
443:           
444:           #asm
445:               MOVLB 0x1F
03AB  003F     MOVLB 0x1F
446:               MOVF FSR0L_SHAD, W
03AC  0868     MOVF PIR1User, W
447:               MOVWF FSR0L         //CLASSB_MarchstartAddress
03AD  0084     MOVWF FSR0L
448:               MOVF FSR0H_SHAD, W
03AE  0869     MOVF Timer1GateUser, W
449:               MOVWF FSR0H         //CLASSB_MarchbufferAddress
03AF  0085     MOVWF FSR0H
450:               MOVF WREG_SHAD, W
03B0  0865     MOVF InterruptsUser, W
451:               MOVLB 0x00
03B1  0020     MOVLB 0x0
452:               MOVWF 0x26     //CLASSB_MarchLength
03B2  00A6     MOVWF CLASSB_MarchLength
453:               MOVF FSR0L, W
03B3  0804     MOVF FSR0L, W
454:               MOVWF 0x20    //CLASSB_MarchstartAddress
03B4  00A0     MOVWF CLASSB_MarchstartAddress
455:               MOVF FSR0H, W
03B5  0805     MOVF FSR0H, W
456:               MOVWF 0x22    //CLASSB_MarchbufferAddress
03B6  00A2     MOVWF CLASSB_MarchbufferAddress
457:           #endasm
458:           
459:               return CLASSB_TEST_PASS;
03B7  3400     RETLW 0x0
460:           }
03B8  082E     MOVF d, W
---  C:/Users/C13819/Documents/Class_B/Class B/ClassB PIC12-16 Library Version 3.00/Microchip/Class B/CLASSB_RAMCheckerBoardTest.c
1:             /**********************************************************************
2:             * © 2013 Microchip Technology Inc.
3:             *
4:             * Project Name:     Class B Library
5:             * FileName:         CLASSB_RAMCheckerBoardTest.c
6:             * Dependencies:     CLASSB_RAMCheckerBoardTest.h
7:             * Processor:        PIC16F1xxx
8:             * Compiler:         XC8
9:             * IDE:              MPLAB® IDE or MPLAB® X
10:            * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
11:            * Description:     This file contains functions to RAM with Checker Board Test.
12:            *
13:            **************************************************************************
14:             * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER: You may use this software, and
15:             * any derivatives created by any person or entity by or on your behalf,
16:             * exclusively with Microchip's products in accordance with applicable
17:             * software license terms and conditions, a copy of which is provided for
18:             * your referencein accompanying documentation. Microchip and its licensors
19:             * retain all ownership and intellectual property rights in the
20:             * accompanying software and in all derivatives hereto.
21:             *
22:             * This software and any accompanying information is for suggestion only.
23:             * It does not modify Microchip's standard warranty for its products. You
24:             * agree that you are solely responsible for testing the software and
25:             * determining its suitability. Microchip has no obligation to modify,
26:             * test, certify, or support the software.
27:             *
28:             * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:             * EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED
30:             * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:             * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE, ITS INTERACTION WITH
32:             * MICROCHIP'S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
33:             * APPLICATION.
34:             *
35:             * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY,
36:             * TORT (INCLUDING NEGLIGENCE OR BREACH OF STATUTORY DUTY), STRICT
37:             * LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT,
38:             * SPECIAL, PUNITIVE, EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE,
39:             * FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE SOFTWARE,
40:             * HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY
41:             * OR THE DAMAGES ARE FORESEEABLE. TO THE FULLEST EXTENT ALLOWABLE BY LAW,
42:             * MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
43:             * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID
44:             * DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
45:             *
46:             * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
47:             * THESE TERMS.
48:             *************************************************************************
49:            *
50:            * REVISION HISTORY:
51:            *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
52:            * Author            Date      Comments on this revision
53:            *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
54:            * CT                09/15/2008  First release of source file
55:            * Mike Cahill       11/11/2010	Updated for HI-TECH v9.80
56:            * MVL               02/22/2011	Modified for HI-TECH v9.81
57:            * EA                03/05/2012	Renamed file as Checkerboard RAM Test
58:            * Corey Simoncic    04/19/2013  Updated for XC-8
59:            *
60:            * Version 		3.00
61:            *
62:            *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
63:            * ADDITIONAL NOTES:
64:            *
65:            **********************************************************************/
66:            #include "CLASSB_RAMCheckerBoardTest.h"
67:                
68:            /*****************************************************************************
69:            * Description:
70:            *     This function that implements a CheckerBoard RAM test.
71:            *     If bufferAddress is NULL the test will be destructive!!!
72:            * Input:
73:            *     *startAddress  	:  pointer to an array declared in user memory for test
74:            *     length 		:  value indicating the number of bytes to test
75:            *     *bufferAddress    :  pointer to location in memory where array will be stored during test
76:            * Return Values:
77:            *     CLASSB_TEST_PASS 	:  return value = 0
78:            *     CLASSB_TEST_FAIL 	:  return value = 1
79:            *
80:            ******************************************************************************/
81:            CLASSBRESULT CLASSB_RAMCheckerboardTest(uint8_t* startAddress, uint8_t length, uint8_t* bufferAddress)
82:            {
83:                volatile unsigned char i;
84:                volatile unsigned char r;
85:                volatile unsigned char checker = 0xAA;
01DB  30AA     MOVLW 0xAA
86:                //volatile unsigned char checkerTest;
87:                uint8_t* tempAddr;
88:            
89:                //***********************************************
90:                if (bufferAddress != NULL)
01DD  0836     MOVF 0x36, W
01DE  0435     IORWF bufferAddress, W
01DF  1903     BTFSC STATUS, 0x2
01E0  29EE     GOTO 0x1EE
91:                memcpy(bufferAddress, startAddress, length); //save user Memory
01E1  0836     MOVF 0x36, W
01E2  00A8     MOVWF length
01E3  0835     MOVF bufferAddress, W
01E4  00A7     MOVWF d1
01E5  0833     MOVF testResult, W
01E6  00AA     MOVWF crcSeed
01E7  0832     MOVF startAddress, W
01E8  00A9     MOVWF s1
01E9  0834     MOVF length, W
01EA  00AB     MOVWF n
01EB  01AC     CLRF 0x2C
01EC  224D     CALL 0x24D
01ED  3180     MOVLP 0x0
92:                tempAddr = startAddress;
01EE  0833     MOVF testResult, W
01EF  00B9     MOVWF 0x39
01F0  0832     MOVF startAddress, W
01F1  00B8     MOVWF tempAddr
93:            
94:                for (r=0;r<2;r++)
01F2  01BA     CLRF r
01F3  3002     MOVLW 0x2
01F4  023A     SUBWF r, W
01F5  1803     BTFSC STATUS, 0x0
01F6  2A3C     GOTO 0x23C
023A  0ABA     INCF r, F
023B  29F3     GOTO 0x1F3
95:                {
96:                    //write checker pattern in RAM
97:                    for (i = 0; i < length; i++)
01F7  01BB     CLRF i
01F8  0834     MOVF length, W
01F9  023B     SUBWF i, W
01FA  1803     BTFSC STATUS, 0x0
01FB  2A0B     GOTO 0x20B
0209  0ABB     INCF i, F
020A  29F8     GOTO 0x1F8
98:                    {
99:                        (*startAddress) = checker;
01FC  083C     MOVF checker, W
01FD  00B7     MOVWF 0x37
01FE  0832     MOVF startAddress, W
01FF  0086     MOVWF FSR1L
0200  0833     MOVF testResult, W
0201  0087     MOVWF FSR1H
0202  0837     MOVF 0x37, W
0203  0081     MOVWF INDF1
100:                       startAddress++;
0204  0AB2     INCF startAddress, F
0205  1903     BTFSC STATUS, 0x2
0206  0AB3     INCF testResult, F
101:                       checker = ~checker;
0207  30FF     MOVLW 0xFF
0208  06BC     XORWF checker, F
102:                   }
103:                   startAddress = tempAddr;
020B  0839     MOVF 0x39, W
020C  00B3     MOVWF testResult
020D  0838     MOVF tempAddr, W
020E  00B2     MOVWF startAddress
104:           
105:                   //read checker pattern in RAM
106:                   for (i=0;i<length;i++)
020F  01BB     CLRF i
0210  0834     MOVF length, W
0211  023B     SUBWF i, W
0212  1803     BTFSC STATUS, 0x0
0213  2A34     GOTO 0x234
0232  0ABB     INCF i, F
0233  2A10     GOTO 0x210
107:                   {
108:                       if ((*startAddress) != checker)
0214  0832     MOVF startAddress, W
0215  0086     MOVWF FSR1L
0216  0833     MOVF testResult, W
0217  0087     MOVWF FSR1H
0218  0801     MOVF INDF1, W
0219  063C     XORWF checker, W
021A  1903     BTFSC STATUS, 0x2
021B  2A2D     GOTO 0x22D
109:                       {
110:                           if (bufferAddress != NULL)
021C  0836     MOVF 0x36, W
021D  0435     IORWF bufferAddress, W
021E  1903     BTFSC STATUS, 0x2
021F  3401     RETLW 0x1
111:                           memcpy(startAddress, bufferAddress, length); //restore user memory
0220  0833     MOVF testResult, W
0221  00A8     MOVWF length
0222  0832     MOVF startAddress, W
0223  00A7     MOVWF d1
0224  0836     MOVF 0x36, W
0225  00AA     MOVWF crcSeed
0226  0835     MOVF bufferAddress, W
0227  00A9     MOVWF s1
0228  0834     MOVF length, W
0229  00AB     MOVWF n
022A  01AC     CLRF 0x2C
022B  224D     CALL 0x24D
112:                           return CLASSB_TEST_FAIL;
022C  3401     RETLW 0x1
113:                       }
114:                       startAddress++;
022D  0AB2     INCF startAddress, F
022E  1903     BTFSC STATUS, 0x2
022F  0AB3     INCF testResult, F
115:                       checker = ~checker;
0230  30FF     MOVLW 0xFF
0231  06BC     XORWF checker, F
116:                   }
117:                   //invert checker pattern
118:                   checker = ~checker;
0234  30FF     MOVLW 0xFF
0235  06BC     XORWF checker, F
119:                   startAddress = tempAddr;
0236  0839     MOVF 0x39, W
0237  00B3     MOVWF testResult
0238  0838     MOVF tempAddr, W
0239  00B2     MOVWF startAddress
120:               }
121:               if (bufferAddress != NULL)
023C  0836     MOVF 0x36, W
023D  0435     IORWF bufferAddress, W
023E  1903     BTFSC STATUS, 0x2
023F  3400     RETLW 0x0
122:               memcpy(startAddress, bufferAddress, length); //restore user memory
0240  0833     MOVF testResult, W
0241  00A8     MOVWF length
0242  0832     MOVF startAddress, W
0243  00A7     MOVWF d1
0244  0836     MOVF 0x36, W
0245  00AA     MOVWF crcSeed
0246  0835     MOVF bufferAddress, W
0247  00A9     MOVWF s1
0248  0834     MOVF length, W
0249  00AB     MOVWF n
024A  01AC     CLRF 0x2C
024B  224D     CALL 0x24D
123:               return CLASSB_TEST_PASS;
024C  3400     RETLW 0x0
124:           
125:           } // End of function
024D  082A     MOVF crcSeed, W
---  C:/Users/C13819/Documents/Class_B/Class B/ClassB PIC12-16 Library Version 3.00/Microchip/Class B/CLASSB_ClockLineFreqTest.c
1:             /**********************************************************************
2:             * © 2013 Microchip Technology Inc.
3:             *
4:             * Project Name:     Class B Library
5:             * FileName:         CLASSB_ClockLineFreqTest.c
6:             * Dependencies:     CLASSB_ClockLineFreqTest.h
7:             * Processor:        PIC16F1xxx
8:             * Compiler:         XC8
9:             * IDE:              MPLAB® IDE or MPLAB® X
10:            * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
11:            * Description:     This file contains functions to check the MCU clock
12:            *                  source.
13:            *
14:            **************************************************************************
15:             * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER: You may use this software, and
16:             * any derivatives created by any person or entity by or on your behalf,
17:             * exclusively with Microchip's products in accordance with applicable
18:             * software license terms and conditions, a copy of which is provided for
19:             * your referencein accompanying documentation. Microchip and its licensors
20:             * retain all ownership and intellectual property rights in the
21:             * accompanying software and in all derivatives hereto.
22:             *
23:             * This software and any accompanying information is for suggestion only.
24:             * It does not modify Microchip's standard warranty for its products. You
25:             * agree that you are solely responsible for testing the software and
26:             * determining its suitability. Microchip has no obligation to modify,
27:             * test, certify, or support the software.
28:             *
29:             * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
30:             * EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED
31:             * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
32:             * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE, ITS INTERACTION WITH
33:             * MICROCHIP'S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
34:             * APPLICATION.
35:             *
36:             * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY,
37:             * TORT (INCLUDING NEGLIGENCE OR BREACH OF STATUTORY DUTY), STRICT
38:             * LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT,
39:             * SPECIAL, PUNITIVE, EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE,
40:             * FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE SOFTWARE,
41:             * HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY
42:             * OR THE DAMAGES ARE FORESEEABLE. TO THE FULLEST EXTENT ALLOWABLE BY LAW,
43:             * MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
44:             * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID
45:             * DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
46:             *
47:             * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
48:             * THESE TERMS.
49:             *************************************************************************
50:            *
51:            * REVISION HISTORY:
52:            *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
53:            * Author            Date      Comments on this revision
54:            *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
55:            * CT                09/15/2008  First release of source file
56:            * Mike Cahill       11/11/2010	Updated for HI-TECH v9.80
57:            * MVL               02/22/2011	Modified for HI-TECH v9.81
58:            * Corey Simoncic    03/25/2013  Updated for XC-8
59:            *
60:            * Version       3.00
61:            *
62:            *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
63:            * ADDITIONAL NOTES:
64:            *
65:            **********************************************************************/
66:            #include "CLASSB_ClockLineFreqTest.h"
67:            
68:            uint8_t InterruptsUser; //INTCON
69:            uint8_t Timer1User;     //T1CON
70:            uint8_t Timer1GateUser; //T1GCON
71:            uint8_t PIE1User;       //PIE1
72:            uint8_t PIR1User;       //PIR1
73:            uint8_t CCPUser;        //CCP1CON
74:            
75:            uint8_t TMR1RollOver;
76:            bool FIRSTCROSS;
77:            uint8_t lineTestEnd;
78:            uint32_t testCount;
79:            uint16_t captureTimer1;
80:            
81:            uint8_t ClockLineFreqTestFlag; //Test result flag
82:            uint32_t expectedCount = 0; //Expected number of counts
83:            uint32_t toleranceCount = 0; //The number of counts allowed due to the tolerance
84:            
85:            uint8_t CLASSB_Line_Freq = 0; //global line frequency variable for use in the interrupt
86:            
87:            /******************************************************************************
88:            * Description:
89:            *   The Clock test implements the independent time slot monitoring H.2.18.10.4
90:            *   defined by the IEC 60730 standard. It verifies the reliability of the system
91:            *   clock (i.e., the system clock should be neither too fast nor too slow)
92:            *
93:            * Input:
94:            *   clockFrequency      - system clock frequency.
95:            *   referenceFrequency  - reference clock frequency.
96:            *   tolerance           - the tolerance level of the system oscillator.
97:            *
98:            * Return Values:
99:            *     None.
100:           ******************************************************************************/
101:           void CLASSB_ClockLineFreqTest(uint32_t clockFrequency, uint8_t lineFrequency, uint8_t tolerance)
102:           {
103:               uint32_t systemFrequency = clockFrequency/4;
104:           
105:               //The line frequency must be a global to be used in the interrupt.
106:               CLASSB_Line_Freq = lineFrequency;
107:           
108:               //Save user initialization.
109:               CLASSB_LineUserSave();
110:               
111:               ClockLineFreqTestFlag = CLASSB_TEST_INPROGRESS;
112:                       
113:               //Initialize modules for Line Frequency Test
114:               LineFreqInit();
115:           
116:               //The test will always be 1 second.
117:               //This makes the expected count the system frequency divided by the line frequency.
118:               expectedCount = systemFrequency/CLASSB_Line_Freq;
119:               toleranceCount = ((uint32_t)tolerance * expectedCount)/100;
120:           }
121:           
122:           void CLASSB_ClockLineFreqISR (void)
123:           {
124:               //The TMR1 interrupt creates a multiplication of the timer counts for rollovers above 0xFFFF
125:               if (TMR1IF)
0AAC  1C11     BTFSS PIR1, 0x0
0AAD  2AB6     GOTO 0x2B6
126:               {
127:                   TMR1RollOver++;
0AAE  0AFD     INCF TMR1RollOver, F
128:                   TMR1IF = 0;
0AAF  1011     BCF PIR1, 0x0
129:                   if(TMR1RollOver > 10)
0AB0  300B     MOVLW 0xB
0AB1  027D     SUBWF TMR1RollOver, W
0AB2  1C03     BTFSS STATUS, 0x0
0AB3  2AB6     GOTO 0x2B6
130:                   {
131:                       ClockLineFreqTestFlag = CLASSB_TEST_TIMEOUT;
0AB4  3002     MOVLW 0x2
0AB5  00E3     MOVWF ClockLineFreqTestFlag
132:                   }
133:               }
134:               //The Capture module will store the TMR1 value in the CCPR when an event occurs.
135:               //This uses that value to compare it to the expected count found above to determine
136:               //if the clock is correct.
137:               if (CCPXIF)
0AB6  1D11     BTFSS PIR1, 0x2
0AB7  0008     RETURN
138:               {
139:                   TMR1 = 0;
0AB8  0196     CLRF TMR1L
0AB9  0197     CLRF TMR1H
140:                   CCPXIF = 0;
0ABA  1111     BCF PIR1, 0x2
141:                   //This disregards the first crossover because it is unknown how long it has been in the period.
142:                   if(!FIRSTCROSS)
0ABB  08E4     MOVF FIRSTCROSS, F
0ABC  1D03     BTFSS STATUS, 0x2
0ABD  2AC2     GOTO 0x2C2
143:                   {
144:                       TMR1RollOver = 0;
0ABE  01FD     CLRF TMR1RollOver
145:                       FIRSTCROSS = 1;
0ABF  01E4     CLRF FIRSTCROSS
0AC0  0AE4     INCF FIRSTCROSS, F
146:                   }
0AC1  2B17     GOTO 0x317
147:                   else
148:                   {
149:                       captureTimer1 = (uint16_t)(CCPRXH << 8) + CCPRXL;
0AC2  0025     MOVLB 0x5
0AC3  0812     MOVF PIR2, W
0AC4  0020     MOVLB 0x0
0AC5  00DE     MOVWF 0x5E
0AC6  01DD     CLRF captureTimer1
0AC7  0025     MOVLB 0x5
0AC8  0811     MOVF PIR1, W
0AC9  0020     MOVLB 0x0
0ACA  07DD     ADDWF captureTimer1, F
0ACB  1803     BTFSC STATUS, 0x0
0ACC  0ADE     INCF 0x5E, F
150:                       if(!lineTestEnd)
0ACD  08EC     MOVF lineTestEnd, F
0ACE  1D03     BTFSS STATUS, 0x2
0ACF  2ADA     GOTO 0x2DA
151:                       {
152:                           TMR1RollOver <<= 16;
0AD0  01FD     CLRF TMR1RollOver
153:                           testCount = (captureTimer1+TMR1RollOver); //This effectively adds the Rollover values to the current test count
0AD1  087D     MOVF TMR1RollOver, W
0AD2  075D     ADDWF captureTimer1, W
0AD3  00D5     MOVWF testCount
0AD4  085E     MOVF 0x5E, W
0AD5  1803     BTFSC STATUS, 0x0
0AD6  0A5E     INCF 0x5E, W
0AD7  00D6     MOVWF 0x56
0AD8  01D7     CLRF 0x57
0AD9  01D8     CLRF 0x58
154:                       }
155:                       testCount = (testCount + (captureTimer1+(0x10000 * TMR1RollOver)))/2;
0ADA  0855     MOVF testCount, W
0ADB  00F0     MOVWF 0x70
0ADC  0856     MOVF 0x56, W
0ADD  00F1     MOVWF 0x71
0ADE  0857     MOVF 0x57, W
0ADF  00F2     MOVWF 0x72
0AE0  0858     MOVF 0x58, W
0AE1  00F3     MOVWF 0x73
0AE2  087D     MOVF TMR1RollOver, W
0AE3  00F4     MOVWF 0x74
0AE4  01F5     CLRF 0x75
0AE5  01F6     CLRF 0x76
0AE6  01F7     CLRF 0x77
0AE7  0875     MOVF 0x75, W
0AE8  00F7     MOVWF 0x77
0AE9  0874     MOVF 0x74, W
0AEA  00F6     MOVWF 0x76
0AEB  01F5     CLRF 0x75
0AEC  01F4     CLRF 0x74
0AED  085D     MOVF captureTimer1, W
0AEE  00F8     MOVWF 0x78
0AEF  085E     MOVF 0x5E, W
0AF0  00F9     MOVWF 0x79
0AF1  01FA     CLRF 0x7A
0AF2  01FB     CLRF 0x7B
0AF3  0878     MOVF 0x78, W
0AF4  07F4     ADDWF 0x74, F
0AF5  0879     MOVF 0x79, W
0AF6  3DF5     ADDWFC 0x75, F
0AF7  087A     MOVF 0x7A, W
0AF8  3DF6     ADDWFC 0x76, F
0AF9  087B     MOVF 0x7B, W
0AFA  3DF7     ADDWFC 0x77, F
0AFB  0874     MOVF 0x74, W
0AFC  07F0     ADDWF 0x70, F
0AFD  0875     MOVF 0x75, W
0AFE  3DF1     ADDWFC 0x71, F
0AFF  0876     MOVF 0x76, W
0B00  3DF2     ADDWFC 0x72, F
0B01  0877     MOVF 0x77, W
0B02  3DF3     ADDWFC 0x73, F
0B03  36F3     LSRF 0x73, F
0B04  0CF2     RRF 0x72, F
0B05  0CF1     RRF 0x71, F
0B06  0CF0     RRF 0x70, F
0B07  0873     MOVF 0x73, W
0B08  00D8     MOVWF 0x58
0B09  0872     MOVF 0x72, W
0B0A  00D7     MOVWF 0x57
0B0B  0871     MOVF 0x71, W
0B0C  00D6     MOVWF 0x56
0B0D  0870     MOVF 0x70, W
0B0E  00D5     MOVWF testCount
156:                       CCPRXL = 0;
0B0F  0025     MOVLB 0x5
0B10  0191     CLRF PIR1
157:                       CCPRXH = 0;
0B11  0192     CLRF PIR2
158:                       lineTestEnd++;
0B12  0020     MOVLB 0x0
0B14  0AEC     INCF lineTestEnd, F
159:                       TMR1RollOver = 0;
0B15  01FD     CLRF TMR1RollOver
160:                       ClockLineFreqTestFlag = CLASSB_TEST_INPROGRESS;
0B13  3003     MOVLW 0x3
0B16  00E3     MOVWF ClockLineFreqTestFlag
161:                   }
162:                   //The test will end when the lineTestEnd counter reaches the line frequency.
163:                   if(lineTestEnd >= CLASSB_Line_Freq)
0B17  0862     MOVF CLASSB_Line_Freq, W
0B18  026C     SUBWF lineTestEnd, W
0B19  1C03     BTFSS STATUS, 0x0
0B1A  0008     RETURN
164:                   {
165:                       if (testCount < (expectedCount - toleranceCount))
0B1B  0859     MOVF toleranceCount, W
0B1C  0251     SUBWF expectedCount, W
0B1D  00F0     MOVWF 0x70
0B1E  085A     MOVF 0x5A, W
0B1F  3B52     SUBWFB 0x52, W
0B20  00F1     MOVWF 0x71
0B21  085B     MOVF 0x5B, W
0B22  3B53     SUBWFB 0x53, W
0B23  00F2     MOVWF 0x72
0B24  085C     MOVF 0x5C, W
0B25  3B54     SUBWFB 0x54, W
0B26  00F3     MOVWF 0x73
0B27  0258     SUBWF 0x58, W
0B28  1D03     BTFSS STATUS, 0x2
0B29  2B34     GOTO 0x334
0B2A  0872     MOVF 0x72, W
0B2B  0257     SUBWF 0x57, W
0B2C  1D03     BTFSS STATUS, 0x2
0B2D  2B34     GOTO 0x334
0B2E  0871     MOVF 0x71, W
0B2F  0256     SUBWF 0x56, W
0B30  1D03     BTFSS STATUS, 0x2
0B31  2B34     GOTO 0x334
0B32  0870     MOVF 0x70, W
0B33  0255     SUBWF testCount, W
0B34  1803     BTFSC STATUS, 0x0
0B35  2B3F     GOTO 0x33F
166:                       {
167:                           CLASSB_LineUserRestore();//Restore user initialization.
0B36  235E     CALL 0x35E
0B37  318A     MOVLP 0xA
168:                           ClockLineFreqTestFlag = CLASSB_TEST_FAIL;
0B38  01E3     CLRF ClockLineFreqTestFlag
0B39  0AE3     INCF ClockLineFreqTestFlag, F
169:                           if (ClockLineFreqTestFail != NULL) //used if function pointer is enabled
0B3A  087C     MOVF ClockLineFreqTestFail, W
0B3B  1903     BTFSC STATUS, 0x2
0B3C  0008     RETURN
170:                           {
171:                               ClockLineFreqTestFail();
0B3D  318B     MOVLP 0xB
0B3E  2B3E     GOTO 0x33E
172:                           }
173:           
174:                       }
175:                       else if (testCount > (expectedCount + toleranceCount))
0B3F  0851     MOVF expectedCount, W
0B40  0759     ADDWF toleranceCount, W
0B41  00F0     MOVWF 0x70
0B42  0852     MOVF 0x52, W
0B43  3D5A     ADDWFC 0x5A, W
0B44  00F1     MOVWF 0x71
0B45  0853     MOVF 0x53, W
0B46  3D5B     ADDWFC 0x5B, W
0B47  00F2     MOVWF 0x72
0B48  0854     MOVF 0x54, W
0B49  3D5C     ADDWFC 0x5C, W
0B4A  00F3     MOVWF 0x73
0B4B  0858     MOVF 0x58, W
0B4C  0273     SUBWF 0x73, W
0B4D  1D03     BTFSS STATUS, 0x2
0B4E  2B59     GOTO 0x359
0B4F  0857     MOVF 0x57, W
0B50  0272     SUBWF 0x72, W
0B51  1D03     BTFSS STATUS, 0x2
0B52  2B59     GOTO 0x359
0B53  0856     MOVF 0x56, W
0B54  0271     SUBWF 0x71, W
0B55  1D03     BTFSS STATUS, 0x2
0B56  2B59     GOTO 0x359
0B57  0855     MOVF testCount, W
0B58  0270     SUBWF 0x70, W
0B59  1C03     BTFSS STATUS, 0x0
176:                       {
177:                           CLASSB_LineUserRestore();//Restore user initialization.
0B5A  2B36     GOTO 0x336
178:                           ClockLineFreqTestFlag = CLASSB_TEST_FAIL;
179:                           if (ClockLineFreqTestFail != NULL) //used if function pointer is enabled
180:                           {
181:                               ClockLineFreqTestFail();
182:                           }
183:                       }
184:                       else
185:                       {
186:                           CLASSB_LineUserRestore();//Restore user initialization.
0B5B  235E     CALL 0x35E
187:                           ClockLineFreqTestFlag = CLASSB_TEST_PASS;
0B5C  01E3     CLRF ClockLineFreqTestFlag
188:                       }
189:                   }
190:               }
191:               return;
192:           }
0B5D  0008     RETURN
193:           
194:           void LineFreqInit (void)
195:           {
196:               T1CON   = 0b00000000;  /*  TIMER1 CONTROL REGISTER 
197:                           _______|_ TMR1ON    0       Stops Timer1
198:                           ______|__ ----      0       Unimplemented
199:                           _____|___ T1SYNC    0       This bit is ignored.
200:                           ____|____ T1OSCEN   0       Dedicated Timer1 oscillator circuit disabled
201:                           __||_____ T1CKPS    00      1:1 Prescale value
202:                           ||_______ TMR1CS    00      Timer1 clock source is instruction clock (Fosc/4) */
203:               T1GCON = 0;
204:               TMR1 = 0; //reset TMR1H:TMR1L
205:               TMR1IF = 0; //reset TMR1 interrupt flag
206:               TMR1IE = 1; //enable TMR1 interrupts
207:           
208:               CCPXCON = 0b00000100;  /*  CCP1 CONTROL REGISTER
209:                           ____||||_ CCP1M     0100    Capture Mode: every falling edge
210:                           __||_____ DC1B      00      Unused
211:                           ||_______ P1M       00      Unused */
212:               CCPXIF = 0; //reset CCP1 interrupt flag
213:               CCPXIE = 1; //enable CCP1 interrupts
214:           
215:               INTCON = 0xC0; //enable global and peripheral interrupts
216:           
217:               TMR1ON = 1; //Start Timer1
218:           }
219:           
220:           void CLASSB_LineUserSave (void)
221:           {
222:               InterruptsUser = INTCON;
223:               CCPUser = CCPXCON;
224:               Timer1User = T1CON;
225:               Timer1GateUser = T1GCON;
226:               PIE1User = PIE1;
227:               PIR1User = PIR1;
228:           }
229:           
230:           void CLASSB_LineUserRestore (void)
231:           {
232:               INTCON = InterruptsUser;
0B5E  0865     MOVF InterruptsUser, W
0B5F  008B     MOVWF INTCON
233:               CCPXCON = CCPUser;
0B60  0861     MOVF CCPUser, W
0B61  0025     MOVLB 0x5
0B62  0093     MOVWF PIR3
234:               T1CON = Timer1User;
0B63  0020     MOVLB 0x0
0B64  086A     MOVF Timer1User, W
0B65  0098     MOVWF T1CON
235:               T1GCON = Timer1GateUser;
0B66  0869     MOVF Timer1GateUser, W
0B67  0099     MOVWF T1GCON
236:               PIE1 = PIE1User;
0B68  0867     MOVF PIE1User, W
0B69  0021     MOVLB 0x1
0B6A  0091     MOVWF PIR1
237:               PIR1 = PIR1User;
0B6B  0020     MOVLB 0x0
0B6C  0868     MOVF PIR1User, W
0B6D  0091     MOVWF PIR1
238:           }
0B6E  0008     RETURN
---  C:/Users/C13819/Documents/Class_B/Class B/ClassB PIC12-16 Library Version 3.00/Microchip/Class B/CLASSB_CRCbyte.c
1:             /**********************************************************************
2:             * © 2013 Microchip Technology Inc.
3:             *
4:             * Project name:     Class B Library
5:             * FileName:         CLASSB_CRCbyte.c
6:             * Dependencies:     CLASSB_CRCbyte.h
7:             * Processor:        PIC16F1xxx
8:             * Compiler:         XC8
9:             * IDE:              MPLAB® IDE or MPLAB® X
10:            *
11:            * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
12:            * Description:     This file contains functions for implementing a CRC test.
13:            *
14:            **************************************************************************
15:             * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER: You may use this software, and
16:             * any derivatives created by any person or entity by or on your behalf,
17:             * exclusively with Microchip's products in accordance with applicable
18:             * software license terms and conditions, a copy of which is provided for
19:             * your referencein accompanying documentation. Microchip and its licensors
20:             * retain all ownership and intellectual property rights in the
21:             * accompanying software and in all derivatives hereto.
22:             *
23:             * This software and any accompanying information is for suggestion only.
24:             * It does not modify Microchip's standard warranty for its products. You
25:             * agree that you are solely responsible for testing the software and
26:             * determining its suitability. Microchip has no obligation to modify,
27:             * test, certify, or support the software.
28:             *
29:             * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
30:             * EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED
31:             * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
32:             * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE, ITS INTERACTION WITH
33:             * MICROCHIP'S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
34:             * APPLICATION.
35:             *
36:             * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY,
37:             * TORT (INCLUDING NEGLIGENCE OR BREACH OF STATUTORY DUTY), STRICT
38:             * LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT,
39:             * SPECIAL, PUNITIVE, EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE,
40:             * FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE SOFTWARE,
41:             * HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY
42:             * OR THE DAMAGES ARE FORESEEABLE. TO THE FULLEST EXTENT ALLOWABLE BY LAW,
43:             * MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
44:             * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID
45:             * DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
46:             *
47:             * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
48:             * THESE TERMS.
49:             ************************************************************************
50:            *
51:            * REVISION HISTORY:
52:            *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
53:            * Author            Date        Comments on this revision
54:            *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
55:            * Corey Simoncic    04/19/2013  Updated for XC-8
56:            *
57:            * Version       3.00
58:            *
59:            *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
60:            * ADDITIONAL NOTES:
61:            *
62:            **********************************************************************/
63:            #include "CLASSB_CRCbyte.h"
64:             
65:            uint16_t crcreg; //the current remainder of the CRC calculation
66:            uint8_t parity; //the parity bit for CRC calculation
67:            uint8_t dataXorCrcHigh; //Data XOR'd with the current CRC High byte
68:             
69:            /******************************************************************************
70:            * Description:
71:            *     This function does the CRC calculation of a single byte.
72:            * Input:
73:            *     dataSequence :  the byte to be tested
74:            *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
75:            
76:            C is current crc value (seed or previous iteration)
77:            D is the current data sequence
78:            S is the data sequence XOR'd with the high byte of the current crc value
79:            P is the parity bit
80:            
81:            S[i] = C8^D0, C9^D1, C10^D2, C11^D3... etc
82:            
83:            parity = C8^C9^C10^C11^C12^C13^C14^C15 ^ D7^D6^D5^D4^D3^D2^D1^D0
84:            
85:            crcreg[0]  =      P
86:            crcreg[1]  =      S0 ^ P
87:            crcreg[2]  =      S1 ^ S0
88:            crcreg[3]  =      S2 ^ S1
89:            crcreg[4]  =      S3 ^ S2
90:            crcreg[5]  =      S4 ^ S3
91:            crcreg[6]  =      S5 ^ S4
92:            crcreg[7]  =      S6 ^ S5
93:            crcreg[8]  = C0 ^ S7 ^ S6
94:            crcreg[9]  = C1      ^ S7
95:            crcreg[10] = C2
96:            crcreg[11] = C3
97:            crcreg[12] = C4
98:            crcreg[13] = C5
99:            crcreg[14] = C6
100:           crcreg[15] = C7 ^ P
101:           ******************************************************************************/
102:           void crcByte(uint8_t dataSequence)
103:           {
03E9  00A7     MOVWF d1
104:               WREG = dataSequence;
03EA  0089     MOVWF WREG
105:           
106:           #asm
107:               banksel _crcreg
03EB  0020     MOVLB 0x0
108:               xorwf   BANKMASK(_crcreg)+1,w           //XOR the upper byte of CRCREG
03EC  0660     XORWF 0x60, W
109:                                                       //with the input data sequence
110:                                                       //This creates S[i]
111:           
112:               movwf   BANKMASK(_dataXorCrcHigh)
03ED  00EB     MOVWF dataXorCrcHigh
113:               movwf   BANKMASK(_parity)
03EE  00ED     MOVWF parity
114:           
115:               //The following section finds the parity of the CRCREG and the Data sequence
116:               swapf   BANKMASK(_parity),w
03EF  0E6D     SWAPF parity, W
117:               xorwf   BANKMASK(_parity),f         //S0^S4, S1^S5... etc
03F0  06ED     XORWF parity, F
118:               lsrf    BANKMASK(_parity),w         //the upper 4 bits are unnecessary
03F1  366D     LSRF parity, W
119:               lsrf    WREG
03F2  3689     LSRF WREG, F
120:               xorwf   BANKMASK(_parity),f         //S0^S4^S1^S5, S2^S6^S3^S7
03F3  06ED     XORWF parity, F
121:               lsrf    BANKMASK(_parity),w         //the upper 6 bits are unnecessary
03F4  366D     LSRF parity, W
122:               xorwf   BANKMASK(_parity),f         //P = S0^S4^S1^S5^S2^S6^S3^S7
03F5  06ED     XORWF parity, F
123:                                                   //the upper 7 bits are unnecessary
124:           
125:               lslf    BANKMASK(_dataXorCrcHigh),w
03F6  356B     LSLF dataXorCrcHigh, W
126:               xorwf   BANKMASK(_dataXorCrcHigh),f     //S0,S1^S0,S2^S1...etc
03F7  06EB     XORWF dataXorCrcHigh, F
127:           
128:               movf    BANKMASK(_crcreg),w         //Puts the lower byte of the CRC into W
03F8  085F     MOVF crcreg, W
129:                                                   //use this to solve for the upper byte
130:               btfsc   BANKMASK(_parity),0
03F9  186D     BTFSC parity, 0x0
131:               xorlw   80h                         //0x80 is used to position the parity bit
03FA  3A80     XORLW 0x80
132:                                                   //on C7 if it is high. Solves for C15
133:           
134:               btfsc   STATUS,0                    //The Carry bit is currently S7
03FB  1803     BTFSC STATUS, 0x0
135:               xorlw   02h                         //0x02 positions S7 on C1 if it is high
03FC  3A02     XORLW 0x2
136:                                                   //Solves for C9
137:           
138:               btfsc   BANKMASK(_dataXorCrcHigh),7 //S7 currently holds S7^S6
03FD  1BEB     BTFSC dataXorCrcHigh, 0x7
139:               xorlw   01h                         //0x01 positions S7^S6 on C0
03FE  3A01     XORLW 0x1
140:                                                   //Solves for C8
141:           
142:               movwf   BANKMASK(_crcreg)+1         //Saves the high byte of CRCREG
03FF  00E0     MOVWF 0x60
143:           
144:               lslf    BANKMASK(_dataXorCrcHigh),w //This shifts S[i] over to position it
0400  356B     LSLF dataXorCrcHigh, W
145:                                                   //on C1:C7
146:               btfsc   BANKMASK(_parity),0
0401  186D     BTFSC parity, 0x0
147:               xorlw   03h                         //0x03 is used to position the parity bit
0402  3A03     XORLW 0x3
148:                                                   //on C0 and C1. Solves for C0:C7
149:           
150:               movwf   BANKMASK(_crcreg)           //Saves the low byte of CRCREG
0403  00DF     MOVWF crcreg
151:           
152:           #endasm
153:           }
0404  0008     RETURN
---  C:/Users/C13819/Documents/Class_B/Class B/ClassB PIC12-16 Library Version 3.00/Microchip/Class B/CLASSB_CRCFlashTest.c
1:             /**********************************************************************
2:             * © 2013 Microchip Technology Inc.
3:             *
4:             * Project Name:     Class B Library
5:             * FileName:         CLASSB_CRCFlashTest.c
6:             * Dependencies:     CLASSB_CRCFlashTest.h
7:             * Processor:        PIC16F1xxx
8:             * Compiler:         XC8
9:             * IDE:              MPLAB® IDE or MPLAB® X
10:            * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
11:            * Description:     This file contains functions to test Flash Memory
12:            *                  with CRC Test.
13:            *
14:            **************************************************************************
15:             * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER: You may use this software, and
16:             * any derivatives created by any person or entity by or on your behalf,
17:             * exclusively with Microchip's products in accordance with applicable
18:             * software license terms and conditions, a copy of which is provided for
19:             * your referencein accompanying documentation. Microchip and its licensors
20:             * retain all ownership and intellectual property rights in the
21:             * accompanying software and in all derivatives hereto.
22:             *
23:             * This software and any accompanying information is for suggestion only.
24:             * It does not modify Microchip's standard warranty for its products. You
25:             * agree that you are solely responsible for testing the software and
26:             * determining its suitability. Microchip has no obligation to modify,
27:             * test, certify, or support the software.
28:             *
29:             * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
30:             * EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED
31:             * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
32:             * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE, ITS INTERACTION WITH
33:             * MICROCHIP'S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
34:             * APPLICATION.
35:             *
36:             * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY,
37:             * TORT (INCLUDING NEGLIGENCE OR BREACH OF STATUTORY DUTY), STRICT
38:             * LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT,
39:             * SPECIAL, PUNITIVE, EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE,
40:             * FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE SOFTWARE,
41:             * HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY
42:             * OR THE DAMAGES ARE FORESEEABLE. TO THE FULLEST EXTENT ALLOWABLE BY LAW,
43:             * MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
44:             * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID
45:             * DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
46:             *
47:             * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
48:             * THESE TERMS.
49:             *************************************************************************
50:            *
51:            * REVISION HISTORY:
52:            *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
53:            * Author            Date      Comments on this revision
54:            *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
55:            * CT                09/15/2008  First release of source file
56:            * Mike Cahill       11/11/2010	Updated for HI-TECH v9.80
57:            * MVL               02/22/2011	Modified for HI-TECH v9.81
58:            * Corey Simoncic    04/19/2013  Updated for XC-8
59:            *
60:            * Version       3.00
61:            *
62:            *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
63:            * ADDITIONAL NOTES:
64:            *
65:            **********************************************************************/
66:            #include "CLASSB_CRCFlashTest.h"
67:            #include "CLASSB_CRCbyte.h"
68:            #include "CLASSB_Types.h"
69:            
70:              /********************************************************************
71:              * Description:
72:              *     This function computes the periodic checksum using the Cyclic Redundancy
73:              *     Check (CRC). It detects the single bit Faults in the invariable memory.
74:              *     This function returns the final CRC Value.
75:              *     CRC-16 is used as a divisor.
76:              *     
77:              *     CRC-16 = 1 1000 0000 0000 0101= 8005(hex)
78:              * Input:
79:              *     startAddress :  start Address from which the CRC needs to be calculated
80:              *     length       :  the number of Flash addresses to be tested
81:              *     crcSeed      :  the initial value of the CRC calculation
82:              *
83:              * Return Values:
84:              *     testResult   :  Returns the final CRC result.
85:              *                                                                  
86:              ********************************************************************/
87:            uint16_t CLASSB_CRCFlashTest(uint16_t startAddress, uint16_t length, uint16_t crcSeed)
88:            {
89:                volatile unsigned int testResult;
90:                uint16_t i;
91:                uint16_t dataSequence;
92:                crcreg = crcSeed;
03B8  082E     MOVF d, W
93:            
94:                for(i=0; i<length; i++)
03BC  01B1     CLRF i
03BD  01B2     CLRF startAddress
03BE  082C     MOVF 0x2C, W
03BF  0232     SUBWF startAddress, W
03C0  1D03     BTFSS STATUS, 0x2
03C1  2BC4     GOTO 0x3C4
03C2  082B     MOVF n, W
03C3  0231     SUBWF i, W
03C4  1803     BTFSC STATUS, 0x0
03C5  2BE0     GOTO 0x3E0
03DB  0020     MOVLB 0x0
03DC  0AB1     INCF i, F
03DD  1903     BTFSC STATUS, 0x2
03DE  0AB2     INCF startAddress, F
03DF  2BBE     GOTO 0x3BE
95:                {
96:                    dataSequence = CLASSB_flashRead(startAddress+i);
03C6  082A     MOVF crcSeed, W
03C7  00A8     MOVWF length
03C8  0829     MOVF s1, W
03C9  00A7     MOVWF d1
03CA  0831     MOVF i, W
03CB  07A7     ADDWF d1, F
03CC  0832     MOVF startAddress, W
03CD  3DA8     ADDWFC length, F
03CE  2405     CALL 0x405
03CF  3180     MOVLP 0x0
03D0  0828     MOVF length, W
03D1  00B0     MOVWF s
03D2  0827     MOVF d1, W
03D3  00AF     MOVWF dataSequence
97:                    crcByte(dataSequence >> 8);
03D4  0830     MOVF s, W
03D5  23E9     CALL 0x3E9
03D6  3180     MOVLP 0x0
98:                    crcByte(dataSequence & 0xFF);
03D7  0020     MOVLB 0x0
03D8  082F     MOVF dataSequence, W
03D9  23E9     CALL 0x3E9
03DA  3180     MOVLP 0x0
99:                }
100:               testResult = crcreg;
03E0  0860     MOVF 0x60, W
03E1  00B4     MOVWF length
03E2  085F     MOVF crcreg, W
03E3  00B3     MOVWF testResult
101:               return testResult;
03E4  0834     MOVF length, W
03E5  00AA     MOVWF crcSeed
03E6  0833     MOVF testResult, W
03E7  00A9     MOVWF s1
102:           }
03E8  0008     RETURN
103:           
104:           /******************************************************************************
105:           * Description:
106:           *     This function reads the flash at the startAddress.
107:           * Input:
108:           *     addr      :  the address of the flash memory to be tested
109:           * Returns:
110:           *     EEDAT     :  The data in the flash address of addr
111:           *
112:           ******************************************************************************/
113:           uint16_t CLASSB_flashRead(uint16_t addr)
114:           {
115:           #ifdef _EECON1_RD_POSN //this will decide between EECON or PMCON for devices without EEPROM
116:               EEADR = addr;
0405  0828     MOVF length, W
0406  0023     MOVLB 0x3
0407  0092     MOVWF PIR2
0408  0020     MOVLB 0x0
0409  0827     MOVF d1, W
040A  0023     MOVLB 0x3
040B  0091     MOVWF PIR1
117:           
118:               EECON1bits.CFGS = 0;    // Do not select Configuration Space
040C  1315     BCF TMR0, 0x6
119:               EECON1bits.EEPGD = 1;   // Do select Program Memory
040D  1795     BSF TMR0, 0x7
120:               EECON1bits.RD = 1;      // Initiate read
040E  1415     BSF TMR0, 0x0
121:               NOP();                  //
040F  0000     NOP
122:               NOP();                  //
0410  0000     NOP
123:           
124:               return EEDAT;
0411  0023     MOVLB 0x3
0412  0814     MOVF 0x14, W
0413  0020     MOVLB 0x0
0414  00A8     MOVWF length
0415  0023     MOVLB 0x3
0416  0813     MOVF PIR3, W
0417  0020     MOVLB 0x0
0418  00A7     MOVWF d1
125:           #else
126:               PMADR = addr;
127:           
128:               PMCON1bits.CFGS = 0;    // Do not select Configuration Space
129:               PMCON1bits.RD = 1;      // Initiate read
130:               NOP();                  //
131:               NOP();                  //
132:           
133:               return PMDAT;
134:           #endif
135:           
136:           }
0419  0008     RETURN
137:           
---  C:/Users/C13819/Documents/Class_B/Class B/ClassB PIC12-16 Library Version 3.00/Microchip/Class B/CLASSB_CRCEEPROMTest.c
1:             /**********************************************************************
2:             * © 2013 Microchip Technology Inc.
3:             *
4:             * Project Name:     Class B Library
5:             * FileName:         CLASSB_CRCEEPROMTest.c
6:             * Dependencies:     CLASSB_CRCEEPROMTest.h
7:             * Processor:        PIC16F1xxx
8:             * Compiler:         XC8
9:             * IDE:              MPLAB® IDE or MPLAB® X
10:            * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
11:            * Description:     This file contains functions to test EEPROM with CRC Test.
12:            *
13:            **************************************************************************
14:             * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER: You may use this software, and
15:             * any derivatives created by any person or entity by or on your behalf,
16:             * exclusively with Microchip's products in accordance with applicable
17:             * software license terms and conditions, a copy of which is provided for
18:             * your referencein accompanying documentation. Microchip and its licensors
19:             * retain all ownership and intellectual property rights in the
20:             * accompanying software and in all derivatives hereto.
21:             *
22:             * This software and any accompanying information is for suggestion only.
23:             * It does not modify Microchip's standard warranty for its products. You
24:             * agree that you are solely responsible for testing the software and
25:             * determining its suitability. Microchip has no obligation to modify,
26:             * test, certify, or support the software.
27:             *
28:             * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:             * EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED
30:             * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:             * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE, ITS INTERACTION WITH
32:             * MICROCHIP'S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
33:             * APPLICATION.
34:             *
35:             * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY,
36:             * TORT (INCLUDING NEGLIGENCE OR BREACH OF STATUTORY DUTY), STRICT
37:             * LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT,
38:             * SPECIAL, PUNITIVE, EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE,
39:             * FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE SOFTWARE,
40:             * HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY
41:             * OR THE DAMAGES ARE FORESEEABLE. TO THE FULLEST EXTENT ALLOWABLE BY LAW,
42:             * MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
43:             * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID
44:             * DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
45:             *
46:             * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
47:             * THESE TERMS.
48:             *************************************************************************
49:            *
50:            * REVISION HISTORY:
51:            *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
52:            * Author            Date      Comments on this revision
53:            *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
54:            * CT                09/15/2008  First release of source file
55:            * Mike Cahill       11/11/2010	Updated for HI-TECH v9.80
56:            * MVL               02/22/2011	Modified for HI-TECH v9.81
57:            * Corey Simoncic    02/21/2013  Updated for XC-8
58:            *
59:            * Version       3.00
60:            *
61:            *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
62:            * ADDITIONAL NOTES:
63:            *
64:            **********************************************************************/
65:            #include "CLASSB_CRCEEPROMTest.h"
66:            #include "CLASSB_CRCbyte.h"
67:            #include "CLASSB_Types.h"
68:            
69:              /********************************************************************
70:              * Description:
71:              *     This function computes the periodic checksum using the Cyclic Redundancy
72:              *     Check (CRC). It detects the single bit Faults in the invariable memory.
73:              *     This function returns the final CRC Value.
74:              *     CRC-16 is used as a divisor.
75:              *     
76:              *     CRC-16 = 1 1000 0000 0000 0101= 8005(hex)
77:              * Input:
78:              *     startAddress :  start Address from which the CRC needs to be calculated
79:              *     length       :  the number of EEPROM addresses to be tested
80:              *     crcSeed      :  the initial value of the CRC calculation
81:              *
82:              * Return Values:
83:              *     testResult   :  Returns the final CRC result.
84:              ********************************************************************/
85:            uint16_t CLASSB_CRCEEPROMTest(uint8_t startAddress, size_t length, uint16_t crcSeed)
86:            {
87:                volatile unsigned int testResult;
88:                int i;
89:                uint8_t dataSequence;
90:                crcreg = crcSeed;
07B6  00AC     MOVWF 0x2C
91:            
92:                for(i=0; i<length; i++)
07BB  01AE     CLRF d
07BC  01AF     CLRF dataSequence
07BD  0829     MOVF s1, W
07BE  022F     SUBWF dataSequence, W
07BF  1D03     BTFSS STATUS, 0x2
07C0  2FC3     GOTO 0x7C3
07C1  0828     MOVF length, W
07C2  022E     SUBWF d, W
07C3  1803     BTFSC STATUS, 0x0
07C4  2FD2     GOTO 0x7D2
07CD  0020     MOVLB 0x0
07CE  0AAE     INCF d, F
07CF  1903     BTFSC STATUS, 0x2
07D0  0AAF     INCF dataSequence, F
07D1  2FBD     GOTO 0x7BD
93:                {
94:                    dataSequence = CLASSB_EEPROMRead(startAddress+i);
07C5  082C     MOVF 0x2C, W
07C6  072E     ADDWF d, W
07C7  27DB     CALL 0x7DB
07C8  3180     MOVLP 0x0
07C9  0020     MOVLB 0x0
07CA  00AD     MOVWF dataSequence
95:                    crcByte(dataSequence);
07CB  23E9     CALL 0x3E9
07CC  3180     MOVLP 0x0
96:                }
97:                testResult = crcreg;
07D2  0860     MOVF 0x60, W
07D3  00B1     MOVWF i
07D4  085F     MOVF crcreg, W
07D5  00B0     MOVWF s
98:                return testResult;
07D6  0831     MOVF i, W
07D7  00A9     MOVWF s1
07D8  0830     MOVF s, W
07D9  00A8     MOVWF length
99:            }
07DA  0008     RETURN
100:           
101:           /******************************************************************************
102:           * Description:
103:           *     This function reads the EEPROM at the startAddress.
104:           * Input:
105:           *     addr      :  the address of the EEPROM memory to be tested
106:           * Returns:
107:           *     EEDAT     :  The data in the EEPROM address of addr
108:           *
109:           ******************************************************************************/
110:           uint8_t CLASSB_EEPROMRead(uint8_t addr)
111:           {
07DB  00A7     MOVWF d1
112:               EEADR = addr;
07DC  0023     MOVLB 0x3
07DD  0091     MOVWF PIR1
07DE  0192     CLRF PIR2
113:           
114:               EECON1bits.CFGS = 0;    // Do not select Configuration Space
07DF  1315     BCF TMR0, 0x6
115:               EECON1bits.EEPGD = 0;   // Do select Program Memory
07E0  1395     BCF TMR0, 0x7
116:               EECON1bits.RD = 1;      // Initiate read
07E1  1415     BSF TMR0, 0x0
117:               NOP();                  //
07E2  0000     NOP
118:               NOP();                  //
07E3  0000     NOP
119:           
120:               return EEDAT;
07E4  0023     MOVLB 0x3
07E5  0813     MOVF PIR3, W
121:           }
07E6  0008     RETURN
---  C:/Users/C13819/Documents/Class_B/Class B/ClassB PIC12-16 Library Version 3.00/Microchip/Class B/CLASSB_CPURegistersTest.c
1:             /**********************************************************************
2:             * © 2013 Microchip Technology Inc.
3:             *
4:             * Project Name:     Class B Library
5:             * FileName:         CLASSB_CPUPCRegisters.c
6:             * Dependencies:     CLASSB_CPUPCRegisters.h
7:             * Processor:        PIC16F1xxx
8:             * Compiler:         XC8
9:             * IDE:              MPLAB® IDE or MPLAB® X
10:            * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
11:            * Description:     This file contains functions to check program counter.
12:            *
13:            **************************************************************************
14:             * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER: You may use this software, and
15:             * any derivatives created by any person or entity by or on your behalf,
16:             * exclusively with Microchip's products in accordance with applicable
17:             * software license terms and conditions, a copy of which is provided for
18:             * your referencein accompanying documentation. Microchip and its licensors
19:             * retain all ownership and intellectual property rights in the
20:             * accompanying software and in all derivatives hereto.
21:             *
22:             * This software and any accompanying information is for suggestion only.
23:             * It does not modify Microchip's standard warranty for its products. You
24:             * agree that you are solely responsible for testing the software and
25:             * determining its suitability. Microchip has no obligation to modify,
26:             * test, certify, or support the software.
27:             *
28:             * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:             * EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED
30:             * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:             * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE, ITS INTERACTION WITH
32:             * MICROCHIP'S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
33:             * APPLICATION.
34:             *
35:             * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY,
36:             * TORT (INCLUDING NEGLIGENCE OR BREACH OF STATUTORY DUTY), STRICT
37:             * LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT,
38:             * SPECIAL, PUNITIVE, EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE,
39:             * FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE SOFTWARE,
40:             * HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY
41:             * OR THE DAMAGES ARE FORESEEABLE. TO THE FULLEST EXTENT ALLOWABLE BY LAW,
42:             * MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
43:             * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID
44:             * DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
45:             *
46:             * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
47:             * THESE TERMS.
48:             *************************************************************************
49:            *
50:            * REVISION HISTORY:
51:            *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
52:            * Author            Date      Comments on this revision
53:            *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
54:            *CT                 09/15/2008  First release of source file
55:            *Mike Cahill        11/11/2010	Updated for HI-TECH v9.80
56:            *MVL                02/22/2011	Modified for HI-TECH v9.80 & v9.81
57:            *EA                 01/20/2013	Updated to XC-8
58:            *Corey Simoncic     06/17/2013  Modified for XC8
59:            *
60:            * Version 		3.0
61:            *
62:            *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
63:            * ADDITIONAL NOTES:
64:            *
65:            **********************************************************************/
66:            #include "CLASSB_CPURegistersTest.h"
67:            
68:            unsigned char tempBSR;
69:            
70:            /********************************************************************************************
71:            * Function Name: SSL_8bit_CPU_RegisterTest      
72:            * 
73:            * Description  : The "SSL_8bit_CPU_RegisterTest" function tests the CPU W register for stuck at 
74:            * faults, insuring that bits in the registers are not stuck at a value. This test can be done 
75:            * by successively doing a write, read and check of 0x55 & 0xAA value into the W register.
76:            * The Register is saved into RAM before the test is performed and restored after the test is done.
77:            *
78:            * Input        : None
79:            *                
80:            * Returns      : return value = 0 Test FAIL 
81:            *                return value = 1 Test PASS 
82:            *********************************************************************************************/
83:            
84:            
85:            CLASSBRESULT CLASSB_CPURegistersTest()
86:            {
87:            //    UserSave();
88:            
89:                tempBSR = BSR;
0B6F  0808     MOVF BSR, W
0B70  0020     MOVLB 0x0
0B71  00EF     MOVWF tempBSR
90:            
91:            /*****************************************************************************
92:            *   Test WREG
93:            ******************************************************************************/
94:                // Test WREG with 0x55
95:                asm("MOVLW 0x55");
0B72  3055     MOVLW 0x55
96:                asm("XORLW 0x55");
0B73  3A55     XORLW 0x55
97:            
98:                if (WREG != 0)
0B74  0809     MOVF WREG, W
0B75  1D03     BTFSS STATUS, 0x2
99:                {
100:                   return CLASSB_TEST_FAIL;
0B76  3401     RETLW 0x1
101:               }
102:           
103:               // Test WREG with 0xAA
104:               asm("MOVLW 0xAA");
0B77  30AA     MOVLW 0xAA
105:               asm("XORLW 0xAA");
0B78  3AAA     XORLW 0xAA
106:           
107:               if (WREG != 0)
0B79  0809     MOVF WREG, W
0B7A  1D03     BTFSS STATUS, 0x2
0B7B  3401     RETLW 0x1
108:               {
109:                   return CLASSB_TEST_FAIL;
110:               }
111:           
112:           /*****************************************************************************
113:           *   Test WREG_SHAD
114:           ******************************************************************************/
115:               //Test WREG_SHAD with 0xAA
116:               WREG_SHAD = 0xAA;
0B7C  30AA     MOVLW 0xAA
0B7D  003F     MOVLB 0x1F
0B7E  00E5     MOVWF InterruptsUser
117:               if (WREG_SHAD != 0xAA)
0B7F  0865     MOVF InterruptsUser, W
0B80  3AAA     XORLW 0xAA
0B81  1D03     BTFSS STATUS, 0x2
0B82  3401     RETLW 0x1
118:               {
119:                   return CLASSB_TEST_FAIL;
120:               }
121:               //Test WREG_SHAD with 0x55
122:               WREG_SHAD = 0x55;
0B83  3055     MOVLW 0x55
0B84  00E5     MOVWF InterruptsUser
123:               if (WREG_SHAD != 0x55)
0B85  0865     MOVF InterruptsUser, W
0B86  3A55     XORLW 0x55
0B87  1D03     BTFSS STATUS, 0x2
0B88  3401     RETLW 0x1
124:               {
125:                   return CLASSB_TEST_FAIL;
126:               }
127:           
128:           /*****************************************************************************
129:           *   Test BSR_SHAD
130:           ******************************************************************************/
131:               //Test BSR_SHAD with 0x0A
132:               BSR_SHAD = 0x0A;
0B89  300A     MOVLW 0xA
0B8A  00E6     MOVWF PCTestFlag
133:               if (BSR_SHAD != 0x0A)
0B8B  0866     MOVF PCTestFlag, W
0B8C  3A0A     XORLW 0xA
0B8D  1D03     BTFSS STATUS, 0x2
0B8E  3401     RETLW 0x1
134:               {
135:                   return CLASSB_TEST_FAIL;
136:               }
137:               //Test BSR_SHAD with 0x15
138:               BSR_SHAD = 0x15;
0B8F  3015     MOVLW 0x15
0B90  00E6     MOVWF PCTestFlag
139:               if (BSR_SHAD != 0x15)
0B91  0866     MOVF PCTestFlag, W
0B92  3A15     XORLW 0x15
0B93  1D03     BTFSS STATUS, 0x2
0B94  3401     RETLW 0x1
140:               {
141:                   return CLASSB_TEST_FAIL;
142:               }
143:           
144:           /*****************************************************************************
145:           *   Test FSR0L_SHAD
146:           ******************************************************************************/
147:               //Test FSR0L_SHAD with 0xAA
148:               FSR0L_SHAD = 0xAA;
0B95  30AA     MOVLW 0xAA
0B96  00E8     MOVWF PIR1User
149:               if (FSR0L_SHAD != 0xAA)
0B97  0868     MOVF PIR1User, W
0B98  3AAA     XORLW 0xAA
0B99  1D03     BTFSS STATUS, 0x2
0B9A  3401     RETLW 0x1
150:               {
151:                   return CLASSB_TEST_FAIL;
152:               }
153:               //Test FSR0L_SHAD with 0x55
154:               FSR0L_SHAD = 0x55;
0B9B  3055     MOVLW 0x55
0B9C  00E8     MOVWF PIR1User
155:               if (FSR0L_SHAD != 0x55)
0B9D  0868     MOVF PIR1User, W
0B9E  3A55     XORLW 0x55
0B9F  1D03     BTFSS STATUS, 0x2
0BA0  3401     RETLW 0x1
156:               {
157:                   return CLASSB_TEST_FAIL;
158:               }
159:           
160:           /*****************************************************************************
161:           *   Test FSR0H_SHAD
162:           ******************************************************************************/
163:               //Test FSR0H_SHAD with 0xAA
164:               FSR0H_SHAD = 0xAA;
0BA1  30AA     MOVLW 0xAA
0BA2  00E9     MOVWF Timer1GateUser
165:               if (FSR0H_SHAD != 0xAA)
0BA3  0869     MOVF Timer1GateUser, W
0BA4  3AAA     XORLW 0xAA
0BA5  1D03     BTFSS STATUS, 0x2
0BA6  3401     RETLW 0x1
166:               {
167:                   return CLASSB_TEST_FAIL;
168:               }
169:               //Test FSR0H_SHAD with 0x55
170:               FSR0H_SHAD = 0x55;
0BA7  3055     MOVLW 0x55
0BA8  00E9     MOVWF Timer1GateUser
171:               if (FSR0H_SHAD != 0x55)
0BA9  0869     MOVF Timer1GateUser, W
0BAA  3A55     XORLW 0x55
0BAB  1D03     BTFSS STATUS, 0x2
0BAC  3401     RETLW 0x1
172:               {
173:                   return CLASSB_TEST_FAIL;
174:               }
175:           
176:           /*****************************************************************************
177:           *   Test FSR1L_SHAD
178:           ******************************************************************************/
179:               //Test FSR1L_SHAD with 0xAA
180:               FSR1L_SHAD = 0xAA;
0BAD  30AA     MOVLW 0xAA
0BAE  00EA     MOVWF Timer1User
181:               if (FSR1L_SHAD != 0xAA)
0BAF  086A     MOVF Timer1User, W
0BB0  3AAA     XORLW 0xAA
0BB1  1D03     BTFSS STATUS, 0x2
0BB2  3401     RETLW 0x1
182:               {
183:                   return CLASSB_TEST_FAIL;
184:               }
185:               //Test FSR1L_SHAD with 0x55
186:               FSR1L_SHAD = 0x55;
0BB3  3055     MOVLW 0x55
0BB4  00EA     MOVWF Timer1User
187:               if (FSR1L_SHAD != 0x55)
0BB5  086A     MOVF Timer1User, W
0BB6  3A55     XORLW 0x55
0BB7  1D03     BTFSS STATUS, 0x2
0BB8  3401     RETLW 0x1
188:               {
189:                   return CLASSB_TEST_FAIL;
190:               }
191:           
192:           /*****************************************************************************
193:           *   Test FSR1H_SHAD
194:           ******************************************************************************/
195:               //Test FSR1H_SHAD with 0xAA
196:               FSR1H_SHAD = 0xAA;
0BB9  30AA     MOVLW 0xAA
0BBA  00EB     MOVWF dataXorCrcHigh
197:               if (FSR1H_SHAD != 0xAA)
0BBB  086B     MOVF dataXorCrcHigh, W
0BBC  3AAA     XORLW 0xAA
0BBD  1D03     BTFSS STATUS, 0x2
0BBE  3401     RETLW 0x1
198:               {
199:                   return CLASSB_TEST_FAIL;
200:               }
201:               //Test FSR1H_SHAD with 0x55
202:               FSR1H_SHAD = 0x55;
0BBF  3055     MOVLW 0x55
0BC0  00EB     MOVWF dataXorCrcHigh
203:               if (FSR1H_SHAD != 0x55)
0BC1  086B     MOVF dataXorCrcHigh, W
0BC2  3A55     XORLW 0x55
0BC3  1D03     BTFSS STATUS, 0x2
0BC4  3401     RETLW 0x1
204:               {
205:                   return CLASSB_TEST_FAIL;
206:               }
207:           
208:           /*****************************************************************************
209:           *   Save User Data in shadow registers
210:           ******************************************************************************/
211:               BSR_SHAD = tempBSR;
0BC5  0020     MOVLB 0x0
0BC6  086F     MOVF tempBSR, W
0BC7  003F     MOVLB 0x1F
0BC8  00E6     MOVWF PCTestFlag
212:               FSR0L_SHAD = FSR0L;
0BC9  0804     MOVF FSR0L, W
0BCA  00E8     MOVWF PIR1User
213:               FSR0H_SHAD = FSR0H;
0BCB  0805     MOVF FSR0H, W
0BCC  00E9     MOVWF Timer1GateUser
214:               FSR1L_SHAD = FSR1L;
0BCD  0806     MOVF FSR1L, W
0BCE  00EA     MOVWF Timer1User
215:               FSR1H_SHAD = FSR1H;
0BCF  0807     MOVF FSR1H, W
0BD0  00EB     MOVWF dataXorCrcHigh
216:           
217:           /*****************************************************************************
218:           *   Test BSR
219:           ******************************************************************************/
220:               //Only BSR<4:0> are R/W
221:               //Test BSR with 0x0A
222:               asm("MOVLB 0x0A");
0BD1  002A     MOVLB 0xA
223:               asm("MOVLW 0x0A");
0BD2  300A     MOVLW 0xA
224:               asm("SUBWF BSR, W");
0BD3  0208     SUBWF BSR, W
225:               if (WREG != 0x00)
0BD4  0809     MOVF WREG, W
0BD5  1903     BTFSC STATUS, 0x2
0BD6  2BD9     GOTO 0x3D9
226:               {
227:                   UserRestore();
0BD7  240D     CALL 0x40D
0BD8  3401     RETLW 0x1
228:                   return CLASSB_TEST_FAIL;
229:               }
230:               //Test BSR with 0x15
231:               asm("MOVLB 0x15");
0BD9  0035     MOVLB 0x15
232:               asm("MOVLW 0x15");
0BDA  3015     MOVLW 0x15
233:               asm("SUBWF BSR, W");
0BDB  0208     SUBWF BSR, W
234:               if (WREG != 0x00)
0BDC  0809     MOVF WREG, W
0BDD  1D03     BTFSS STATUS, 0x2
0BDE  2BD7     GOTO 0x3D7
235:               {
236:                   UserRestore();
237:                   return CLASSB_TEST_FAIL;
238:               }
239:           
240:           /*****************************************************************************
241:           *   Test FSR
242:           ******************************************************************************/
243:               //Clear FSR
244:               FSR0 = 0;
0BDF  0184     CLRF FSR0L
0BE0  0185     CLRF FSR0H
245:               FSR1 = 0;
0BE1  0186     CLRF FSR1L
0BE2  0187     CLRF FSR1H
246:               //Test FSR0 with 0x5555
247:               FSR0 = 0x5555;
0BE3  3055     MOVLW 0x55
0BE4  0085     MOVWF FSR0H
0BE5  0084     MOVWF FSR0L
248:               if (FSR0 != 0x5555)
0BE6  0805     MOVF FSR0H, W
0BE7  3A55     XORLW 0x55
0BE8  3055     MOVLW 0x55
0BE9  1903     BTFSC STATUS, 0x2
0BEA  0604     XORWF FSR0L, W
0BEB  1D03     BTFSS STATUS, 0x2
0BEC  2BD7     GOTO 0x3D7
249:               {
250:                   UserRestore();
251:                   return CLASSB_TEST_FAIL;
252:               }
253:               //Test FSR0 with 0xAAAA
254:               FSR0 = 0xAAAA;
0BED  30AA     MOVLW 0xAA
0BEE  0085     MOVWF FSR0H
0BEF  0084     MOVWF FSR0L
255:               if (FSR0 != 0xAAAA)
0BF0  0805     MOVF FSR0H, W
0BF1  3AAA     XORLW 0xAA
0BF2  30AA     MOVLW 0xAA
0BF3  1903     BTFSC STATUS, 0x2
0BF4  0604     XORWF FSR0L, W
0BF5  1D03     BTFSS STATUS, 0x2
0BF6  2BD7     GOTO 0x3D7
256:               {
257:                   UserRestore();
258:                   return CLASSB_TEST_FAIL;
259:               }
260:               //Test FSR1 with 0x5555
261:               FSR1 = 0x5555;
0BF7  3055     MOVLW 0x55
0BF8  0087     MOVWF FSR1H
0BF9  0086     MOVWF FSR1L
262:               if (FSR1 != 0x5555)
0BFA  0807     MOVF FSR1H, W
0BFB  3A55     XORLW 0x55
0BFC  3055     MOVLW 0x55
0BFD  1903     BTFSC STATUS, 0x2
0BFE  0606     XORWF FSR1L, W
0BFF  1D03     BTFSS STATUS, 0x2
0C00  2BD7     GOTO 0x3D7
263:               {
264:                   UserRestore();
265:                   return CLASSB_TEST_FAIL;
266:               }
267:               //Test FSR1 with 0xAAAA
268:               FSR1 = 0xAAAA;
0C01  30AA     MOVLW 0xAA
0C02  0087     MOVWF FSR1H
0C03  0086     MOVWF FSR1L
269:               if (FSR1 != 0xAAAA)
0C04  0807     MOVF FSR1H, W
0C05  3AAA     XORLW 0xAA
0C06  30AA     MOVLW 0xAA
0C07  1903     BTFSC STATUS, 0x2
0C08  0606     XORWF FSR1L, W
0C09  1D03     BTFSS STATUS, 0x2
0C0A  2BD7     GOTO 0x3D7
270:               {
271:                   UserRestore();
272:                   return CLASSB_TEST_FAIL;
273:               }
274:           
275:           /*****************************************************************************
276:           *   All tests passed.
277:           *   Restore user data.
278:           ******************************************************************************/
279:               UserRestore();
0C0B  240D     CALL 0x40D
280:               return CLASSB_TEST_PASS;
0C0C  3400     RETLW 0x0
281:           }
282:           
283:           //void UserSave (void)
284:           //{
285:           //    tempBSR = BSR;
286:           //    tempFSR0L = FSR0L;
287:           //    tempFSR0H = FSR0H;
288:           //    tempFSR1L = FSR1L;
289:           //    tempFSR1H = FSR1H;
290:           //}
291:           
292:           void UserRestore (void)
293:           {
294:               FSR0L = FSR0L_SHAD;
0C0D  003F     MOVLB 0x1F
0C0E  0868     MOVF PIR1User, W
0C0F  0084     MOVWF FSR0L
295:               FSR0H = FSR0H_SHAD;
0C10  0869     MOVF Timer1GateUser, W
0C11  0085     MOVWF FSR0H
296:               FSR1L = FSR1L_SHAD;
0C12  086A     MOVF Timer1User, W
0C13  0086     MOVWF FSR1L
297:               FSR1H = FSR1H_SHAD;
0C14  086B     MOVF dataXorCrcHigh, W
0C15  0087     MOVWF FSR1H
298:               BSR = BSR_SHAD;
0C16  0866     MOVF PCTestFlag, W
0C17  0088     MOVWF BSR
299:           }
0C18  0008     RETURN
---  C:/Users/C13819/Documents/Class_B/Class B/ClassB PIC12-16 Library Version 3.00/Microchip/Class B/CLASSB_CPUPCTest.c
1:             /**********************************************************************
2:             * © 2013 Microchip Technology Inc.
3:             *
4:             * Project Name:     Class B Library
5:             * FileName:         CLASSB_CPUPCTest.c
6:             * Dependencies:     CLASSB_CPUPCTest.h
7:             * Processor:        PIC16F1xxx
8:             * Compiler:         XC8
9:             * IDE:              MPLAB® IDE or MPLAB® X
10:            * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
11:            * Description:     This file contains functions to check program counter.
12:            *
13:            **************************************************************************
14:             * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER: You may use this software, and
15:             * any derivatives created by any person or entity by or on your behalf,
16:             * exclusively with Microchip's products in accordance with applicable
17:             * software license terms and conditions, a copy of which is provided for
18:             * your referencein accompanying documentation. Microchip and its licensors
19:             * retain all ownership and intellectual property rights in the
20:             * accompanying software and in all derivatives hereto.
21:             *
22:             * This software and any accompanying information is for suggestion only.
23:             * It does not modify Microchip's standard warranty for its products. You
24:             * agree that you are solely responsible for testing the software and
25:             * determining its suitability. Microchip has no obligation to modify,
26:             * test, certify, or support the software.
27:             *
28:             * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:             * EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED
30:             * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:             * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE, ITS INTERACTION WITH
32:             * MICROCHIP'S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
33:             * APPLICATION.
34:             *
35:             * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY,
36:             * TORT (INCLUDING NEGLIGENCE OR BREACH OF STATUTORY DUTY), STRICT
37:             * LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT,
38:             * SPECIAL, PUNITIVE, EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE,
39:             * FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE SOFTWARE,
40:             * HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY
41:             * OR THE DAMAGES ARE FORESEEABLE. TO THE FULLEST EXTENT ALLOWABLE BY LAW,
42:             * MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
43:             * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID
44:             * DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
45:             *
46:             * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
47:             * THESE TERMS.
48:             *************************************************************************
49:            *
50:            * REVISION HISTORY:
51:            *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
52:            * Author            Date      Comments on this revision
53:            *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
54:            * CT                09/27/2007  First release of source file
55:            * Mike Cahill       11/11/2010	Updated for HI-TECH v9.80
56:            * MVL               02/22/2011	Tested with HI-TECH v9.81
57:            * Corey Simoncic    04/18/2013  Updated for XC8
58:            *
59:            * Version 		3.00
60:            *
61:            *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
62:            * ADDITIONAL NOTES:
63:            *
64:            **********************************************************************/
65:            #include "CLASSB_CPUPCTest.h"
66:            
67:            static uint8_t PCTestFlag = 0;
68:            
69:            CLASSBRESULT CLASSB_CPUPCTest()
70:            {
71:                PCTestFlag = 2;
07E7  3002     MOVLW 0x2
07E8  00E6     MOVWF PCTestFlag
72:                CLASSB_PCTrap1();
07E9  3195     MOVLP 0x15
07EA  2554     CALL 0x554
07EB  3180     MOVLP 0x0
73:                CLASSB_PCTrap2();
07EC  318A     MOVLP 0xA
07ED  22A9     CALL 0x2A9
07EE  3180     MOVLP 0x0
74:                
75:                CLASSB_CPUPCTestFunction1();
07EF  3195     MOVLP 0x15
07F0  2555     CALL 0x555
07F1  3180     MOVLP 0x0
76:                CLASSB_CPUPCTestFunction2();
07F2  318A     MOVLP 0xA
07F3  22AA     CALL 0x2AA
07F4  3180     MOVLP 0x0
77:            
78:                if (!PCTestFlag)
07F5  08E6     MOVF PCTestFlag, F
07F6  1903     BTFSC STATUS, 0x2
79:                {
80:                    return CLASSB_TEST_PASS;
07F7  3400     RETLW 0x0
81:                }
82:                else
83:                {
84:                    return CLASSB_TEST_FAIL;
07F8  3401     RETLW 0x1
85:                }
86:            }
07F9  0064     CLRWDT
87:            
88:            void CLASSB_CPUPCTestFunction1(void)
89:            {
90:                PCTestFlag--;
91:                return;
92:            }
93:            
94:            void CLASSB_CPUPCTestFunction2(void)
95:            {
96:                PCTestFlag--;
97:                return;
98:            }
99:            
100:           void CLASSB_PCTrap1 (void)
101:           {
102:               return;
103:           }
104:           void CLASSB_PCTrap2 (void)
105:           {
106:               return;
107:           }
---  C:/Users/C13819/Documents/Class_B/Class B/ClassB PIC12-16 Library Version 3.00/Class B Demos/CLASSB_AllTestsDemo.X/AllTestsMain.c
1:             /**********************************************************************
2:             * © 2013 Microchip Technology Inc.
3:             *
4:             * Project Name:     Class B Library
5:             * FileName:         AllTestsMain.c
6:             * Dependencies:     
7:             * Processor:        PIC16F1xxx
8:             * Compiler:         XC8
9:             * IDE:              MPLAB® IDE or MPLAB® X
10:            * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
11:            * Description:     This file contains the main function to demonstrate
12:            *		   the use of the Microchip CLASSB library.
13:            *
14:            **************************************************************************
15:             * MICROCHIP SOFTWARE NOTICE AND DISCLAIMER: You may use this software, and
16:             * any derivatives created by any person or entity by or on your behalf,
17:             * exclusively with Microchip's products in accordance with applicable
18:             * software license terms and conditions, a copy of which is provided for
19:             * your referencein accompanying documentation. Microchip and its licensors
20:             * retain all ownership and intellectual property rights in the
21:             * accompanying software and in all derivatives hereto.
22:             *
23:             * This software and any accompanying information is for suggestion only.
24:             * It does not modify Microchip's standard warranty for its products. You
25:             * agree that you are solely responsible for testing the software and
26:             * determining its suitability. Microchip has no obligation to modify,
27:             * test, certify, or support the software.
28:             *
29:             * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
30:             * EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED
31:             * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
32:             * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE, ITS INTERACTION WITH
33:             * MICROCHIP'S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
34:             * APPLICATION.
35:             *
36:             * IN NO EVENT, WILL MICROCHIP BE LIABLE, WHETHER IN CONTRACT, WARRANTY,
37:             * TORT (INCLUDING NEGLIGENCE OR BREACH OF STATUTORY DUTY), STRICT
38:             * LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE, FOR ANY INDIRECT,
39:             * SPECIAL, PUNITIVE, EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE,
40:             * FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE SOFTWARE,
41:             * HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY
42:             * OR THE DAMAGES ARE FORESEEABLE. TO THE FULLEST EXTENT ALLOWABLE BY LAW,
43:             * MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
44:             * SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID
45:             * DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
46:             *
47:             * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
48:             * THESE TERMS.
49:             *************************************************************************
50:            *
51:            * REVISION HISTORY:
52:            *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
53:            * Author            Date      Comments on this revision
54:            *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
55:            * CT                09/15/2008  First release of source file
56:            * Mike Cahill       11/11/2010	Updated for HI-TECH v9.80
57:            * MVL               02/22/2011	Modified for HI-TECH v9.81
58:            * Corey Simoncic    03/25/2013  Updated for XC-8 PRO v1.12
59:            *
60:            * Version       3.00
61:            *
62:            *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
63:            * ADDITIONAL NOTES:
64:            *
65:            **********************************************************************/
66:            #include "CLASSB_config.h"
67:            #include "CLASSB.h"
68:            
69:            // PIC16F1937 Configuration Bit Settings
70:            
71:            #include <xc.h>
72:            
73:            // CONFIG1
74:            #pragma config FOSC = INTOSC    // Oscillator Selection (INTOSC oscillator: I/O function on CLKIN pin)
75:            #pragma config WDTE = OFF       // Watchdog Timer Enable (WDT disabled)
76:            #pragma config PWRTE = OFF      // Power-up Timer Enable (PWRT disabled)
77:            #pragma config MCLRE = ON      // MCLR Pin Function Select (MCLR/VPP pin function is digital input)
78:            #pragma config CP = OFF         // Flash Program Memory Code Protection (Program memory code protection is disabled)
79:            #pragma config CPD = OFF        // Data Memory Code Protection (Data memory code protection is disabled)
80:            #pragma config BOREN = OFF      // Brown-out Reset Enable (Brown-out Reset disabled)
81:            #pragma config CLKOUTEN = OFF   // Clock Out Enable (CLKOUT function is disabled. I/O or oscillator function on the CLKOUT pin)
82:            #pragma config IESO = OFF       // Internal/External Switchover (Internal/External Switchover mode is disabled)
83:            #pragma config FCMEN = OFF      // Fail-Safe Clock Monitor Enable (Fail-Safe Clock Monitor is disabled)
84:            
85:            // CONFIG2
86:            #pragma config WRT = OFF        // Flash Memory Self-Write Protection (Write protection off)
87:            #pragma config VCAPEN = OFF     // Voltage Regulator Capacitor Enable (All VCAP pin functionality is disabled)
88:            #pragma config PLLEN = OFF      // PLL Enable (4x PLL disabled)
89:            #pragma config STVREN = OFF      // Stack Overflow/Underflow Reset Enable (Stack Overflow or Underflow will cause a Reset)
90:            #pragma config BORV = LO        // Brown-out Reset Voltage Selection (Brown-out Reset Voltage (Vbor), low trip point selected.)
91:            #pragma config LVP = OFF        // Low-Voltage Programming Enable (High-voltage on MCLR/VPP must be used for programming)
92:            
93:            void ErrorMode(void);
94:            
95:            void interrupt ISR (void)
96:            {
0004  3180     MOVLP 0x0
97:                if(ClockLineFreqTestFlag == CLASSB_TEST_INPROGRESS)
0005  0020     MOVLB 0x0
0006  0863     MOVF ClockLineFreqTestFlag, W
0007  3A03     XORLW 0x3
0008  1D03     BTFSS STATUS, 0x2
0009  0009     RETFIE
98:                {
99:                    CLASSB_ClockLineFreqISR();
000A  318A     MOVLP 0xA
000B  22AC     CALL 0x2AC
100:               }
101:           }
000C  0009     RETFIE
102:           
103:           void Init()
104:           {
105:               OSCCON = 0b01111000; //16 MHz
0271  3078     MOVLW 0x78
0272  0021     MOVLB 0x1
0273  0099     MOVWF T1GCON
106:               TRISA = 0;
0274  018C     CLRF PORTA
107:               TRISB = 0;
0275  018D     CLRF PORTB
108:               TRISC = 0;
0276  018E     CLRF PORTC
109:               TRISD = 0;
0277  018F     CLRF PORTD
110:               LATA = 0;
0278  0022     MOVLB 0x2
0279  018C     CLRF PORTA
111:               LATB = 0;
027A  018D     CLRF PORTB
112:               LATC = 0;
027B  018E     CLRF PORTC
113:               LATD = 0;
027C  018F     CLRF PORTD
114:               TRISC2 = 1; //This is for the zero-cross on CCP1
027D  0021     MOVLB 0x1
027E  150E     BSF PORTC, 0x2
115:               TRISC0 = 1; //These are for T1OSC
027F  140E     BSF PORTC, 0x0
116:               TRISC1 = 1;
0280  148E     BSF PORTC, 0x1
117:               T1CON = 0b10001000; //T1OSC, dedicated osc enabled.
0281  3088     MOVLW 0x88
0282  0020     MOVLB 0x0
0283  0098     MOVWF T1CON
118:           }
0284  0008     RETURN
119:           
120:           void main()
121:           {
122:               Init();
0020  2271     CALL 0x271
0021  3180     MOVLP 0x0
123:           
124:               volatile unsigned char testResult;
125:           
126:           /******************************************************************************
127:           *   Program Counter Test.
128:           ******************************************************************************/
129:               CLASSBRESULT  ProgramCounterResult = CLASSB_TEST_INPROGRESS;
130:               ProgramCounterResult = CLASSB_CPUPCTest();
0022  27E7     CALL 0x7E7
0023  3180     MOVLP 0x0
0024  00CF     MOVWF ProgramCounterResult
131:           
132:               if (ProgramCounterResult == CLASSB_TEST_PASS)
0025  08CF     MOVF ProgramCounterResult, F
0026  1D03     BTFSS STATUS, 0x2
0027  282A     GOTO 0x2A
133:               {
134:                   asm("nop");		/* Test pass */
0028  0000     NOP
135:               }
0029  282C     GOTO 0x2C
136:               else
137:               {
138:                   ErrorMode();		/* Test not pass */
002A  20A6     CALL 0xA6
002B  3180     MOVLP 0x0
139:               }
140:           
141:           /******************************************************************************
142:           *   CPU Registers Test.
143:           ******************************************************************************/
144:               //Do a check to see if the Program Counter did not error.
145:               if (ProgramCounterResult == CLASSB_TEST_INPROGRESS)
002C  0020     MOVLB 0x0
002D  084F     MOVF ProgramCounterResult, W
002E  3A03     XORLW 0x3
002F  1D03     BTFSS STATUS, 0x2
0030  2832     GOTO 0x32
146:                   ErrorMode();
0031  20A6     CALL 0xA6
147:           
148:               testResult = CLASSB_CPURegistersTest();
0032  318B     MOVLP 0xB
0033  236F     CALL 0x36F
0034  3180     MOVLP 0x0
0035  0020     MOVLB 0x0
0036  00D0     MOVWF testResult
149:           
150:               if (testResult == CLASSB_TEST_PASS)
0037  08D0     MOVF testResult, F
0038  1D03     BTFSS STATUS, 0x2
0039  283C     GOTO 0x3C
151:               {
152:                   asm("nop");		/* Test pass */
003A  0000     NOP
153:               }
003B  283E     GOTO 0x3E
154:               else
155:               {
156:                   ErrorMode();		/* Test not pass */
003C  20A6     CALL 0xA6
003D  3180     MOVLP 0x0
157:               }
158:           
159:           /******************************************************************************
160:           *   Clock Line Frequency Test.
161:           ******************************************************************************/
162:           //    uint32_t clockFrequency = 16000000; //system clock: 16MHz
163:           //    uint32_t lineFrequency = 60; //reference clock: 60Hz zero-cross
164:           //    uint8_t tolerance = 5; //Tolerance level: 5%
165:           //
166:           //    CLASSB_ClockLineFreqTest(clockFrequency, lineFrequency, tolerance);
167:           //
168:           ////For this demo the code will wait for the test to finish.
169:           ////In application, code can be placed here as long as it is ok to be interrupted!
170:           //    while (ClockLineFreqTestFlag == CLASSB_TEST_INPROGRESS);
171:           //
172:           //    if (ClockLineFreqTestFlag == CLASSB_TEST_PASS)
173:           //    {
174:           //        asm("nop");     /* Test pass */
175:           //    }
176:           //    else
177:           //    {
178:           //        ErrorMode();	/* Test not pass */
179:           //    }
180:           //
181:           ///******************************************************************************
182:           //*   Clock Test.
183:           //******************************************************************************/
184:           //    uint32_t clockFrequency = 16000000; //system clock: 16MHz
185:           //    uint32_t referenceFrequency = 32768; //reference clock: 32.768kHz
186:           //    uint8_t msec = 20; //Test time: 20ms
187:           //    uint8_t tolerance = 5; //Tolerance level: 5%
188:           //
189:           //    testResult = CLASSB_ClockTest(clockFrequency, referenceFrequency, msec, tolerance);
190:           //
191:           //    if (testResult == CLASSB_TEST_PASS)
192:           //    {
193:           //        asm("nop");	/* Test pass */
194:           //    }
195:           //    else
196:           //    {
197:           //        ErrorMode();	/* Test not pass */
198:           //    }
199:           
200:           /******************************************************************************
201:           *   March C Test. (This example tests Bank 0)
202:           ******************************************************************************/
203:               CLASSB_MarchstartAddress = (char*)0x20;
003E  3020     MOVLW 0x20
003F  0020     MOVLB 0x0
0040  00A0     MOVWF CLASSB_MarchstartAddress
0042  01A1     CLRF 0x21
204:               CLASSB_MarchbufferAddress = (char*)0xA0;
0041  30A0     MOVLW 0xA0
0043  00A2     MOVWF CLASSB_MarchbufferAddress
0045  01A3     CLRF 0x23
205:               CLASSB_MarchLength = 0x50;
0044  3050     MOVLW 0x50
0046  00A6     MOVWF CLASSB_MarchLength
206:           
207:               testResult = CLASSB_RAMMarchCTest();
0047  241A     CALL 0x41A
0048  3180     MOVLP 0x0
0049  0020     MOVLB 0x0
004A  00D0     MOVWF testResult
208:           
209:               if (testResult==CLASSB_TEST_PASS)
004B  08D0     MOVF testResult, F
004C  1D03     BTFSS STATUS, 0x2
004D  2850     GOTO 0x50
210:               {
211:                   asm("nop");	/* Test pass */
004E  0000     NOP
212:               }
004F  2852     GOTO 0x52
213:               else
214:               {
215:                   ErrorMode();	/* Test not pass */
0050  20A6     CALL 0xA6
0051  3180     MOVLP 0x0
216:               }
217:           
218:           /******************************************************************************
219:           *   March C Stack Test.
220:           ******************************************************************************/
221:               CLASSB_MarchbufferAddress = (char*)0x27;
0052  3027     MOVLW 0x27
0053  0020     MOVLB 0x0
0054  00A2     MOVWF CLASSB_MarchbufferAddress
0056  01A3     CLRF 0x23
222:               CLASSB_MarchLength = 33;
0055  3021     MOVLW 0x21
0057  00A6     MOVWF CLASSB_MarchLength
223:           
224:               testResult = CLASSB_RAMMarchCStackTest();
0058  2661     CALL 0x661
0059  3180     MOVLP 0x0
005A  00D0     MOVWF testResult
225:           
226:               if (testResult==CLASSB_TEST_PASS)
005B  08D0     MOVF testResult, F
005C  1D03     BTFSS STATUS, 0x2
005D  2860     GOTO 0x60
227:               {
228:                   asm("nop");	/* Test pass */
005E  0000     NOP
229:               }
005F  2862     GOTO 0x62
230:               else
231:               {
232:                   ErrorMode();	/* Test not pass */
0060  20A6     CALL 0xA6
0061  3180     MOVLP 0x0
233:               }
234:           
235:           /******************************************************************************
236:           *   March B Test. (This example tests BANK 0)
237:           ******************************************************************************/
238:               CLASSB_MarchstartAddress = (char*)0x20;
0062  3020     MOVLW 0x20
0063  0020     MOVLB 0x0
0064  00A0     MOVWF CLASSB_MarchstartAddress
0066  01A1     CLRF 0x21
239:               CLASSB_MarchbufferAddress = (char*)0xB0;
0065  30B0     MOVLW 0xB0
0067  00A2     MOVWF CLASSB_MarchbufferAddress
0069  01A3     CLRF 0x23
240:               CLASSB_MarchLength = 0x50;
0068  3050     MOVLW 0x50
006A  00A6     MOVWF CLASSB_MarchLength
241:           
242:               testResult = CLASSB_RAMMarchBTest();
006B  20AE     CALL 0xAE
006C  3180     MOVLP 0x0
006D  0020     MOVLB 0x0
006E  00D0     MOVWF testResult
243:           
244:               if (testResult==CLASSB_TEST_PASS)
006F  08D0     MOVF testResult, F
0070  1D03     BTFSS STATUS, 0x2
0071  2874     GOTO 0x74
245:               {
246:                   asm("nop");	/* Test pass */
0072  0000     NOP
247:               }
0073  2876     GOTO 0x76
248:               else
249:               {
250:                   ErrorMode();	/* Test not pass */
0074  20A6     CALL 0xA6
0075  3180     MOVLP 0x0
251:               }
252:           
253:           /******************************************************************************
254:           *   Initial EEPROM CRC test.
255:           ******************************************************************************/    
256:               uint8_t EEPROMAddress = 0x01;
257:               size_t length = 254;
258:               uint16_t crcSeed = 0xFFFF;
259:               volatile unsigned int CLASSB_EEPROMtestResult;
260:           
261:               CLASSB_EEPROMtestResult = CLASSB_CRCEEPROMTest(EEPROMAddress,length,crcSeed);
0076  30FE     MOVLW 0xFE
0077  0020     MOVLB 0x0
0078  00A8     MOVWF length
0079  30FF     MOVLW 0xFF
007A  01A9     CLRF s1
007B  00AA     MOVWF crcSeed
007C  00AB     MOVWF n
007D  3001     MOVLW 0x1
007E  27B6     CALL 0x7B6
007F  3180     MOVLP 0x0
0080  0829     MOVF s1, W
0081  00C0     MOVWF 0x40
0082  0828     MOVF length, W
0083  00BF     MOVWF CLASSB_EEPROMtestResult
262:               
263:               
264:           /******************************************************************************
265:           *   Initial Flash CRC test.
266:           ******************************************************************************/  
267:               uint16_t FlashAddress = 0x00;
268:               uint16_t Flashlength = 0x2000;
269:               crcSeed = 0xFFFF;
270:               volatile unsigned int CLASSB_FlashtestResult;
271:               
272:               CLASSB_FlashtestResult = CLASSB_CRCFlashTest(FlashAddress,Flashlength,crcSeed);
0084  3020     MOVLW 0x20
0085  01A9     CLRF s1
0086  01AA     CLRF crcSeed
0087  01AB     CLRF n
0088  00AC     MOVWF 0x2C
0089  30FF     MOVLW 0xFF
008A  00AD     MOVWF dataSequence
008B  00AE     MOVWF d
008C  23B8     CALL 0x3B8
008D  3180     MOVLP 0x0
008E  082A     MOVF crcSeed, W
008F  00C6     MOVWF 0x46
0090  0829     MOVF s1, W
0091  00C5     MOVWF CLASSB_FlashtestResult
273:           
274:           //The Check Values for the Flash and EEPROM can now be saved for future
275:           //comparison or compared to a known constant, depending on the application
276:           
277:           /******************************************************************************
278:           *   Checkerboard Test
279:           ******************************************************************************/
280:               uint8_t* CheckerStartAddress;
281:               uint8_t* CheckerBufferAddress;
282:               uint8_t CheckerLength;
283:           
284:           //In this example we show the checkerboard test used on RAM locations
285:           //0x50 - 0x57. The Checkerboard should be used as a faster alternative
286:           //to the March Tests during run-time. Safety specific RAM locations
287:           //should be tested with this method.
288:               CheckerStartAddress = (char*)0x50;
289:               CheckerBufferAddress = (char*)0x58;
290:               CheckerLength = 8;
291:           
292:               testResult = CLASSB_RAMCheckerboardTest(CheckerStartAddress, CheckerLength, CheckerBufferAddress);
0092  3050     MOVLW 0x50
0093  00B2     MOVWF startAddress
0094  3008     MOVLW 0x8
0095  01B3     CLRF testResult
0096  00B4     MOVWF length
0097  3058     MOVLW 0x58
0098  00B5     MOVWF bufferAddress
0099  01B6     CLRF 0x36
009A  21DB     CALL 0x1DB
009B  3180     MOVLP 0x0
009C  00D0     MOVWF testResult
293:           
294:               if (testResult==CLASSB_TEST_PASS)
009D  08D0     MOVF testResult, F
009E  1D03     BTFSS STATUS, 0x2
009F  28A2     GOTO 0xA2
295:               {
296:                   asm("nop");	/* Test pass */
00A0  0000     NOP
297:               }
00A1  28A4     GOTO 0xA4
298:               else
299:               {
300:                   ErrorMode();	/* Test not pass */
00A2  20A6     CALL 0xA6
00A3  3180     MOVLP 0x0
301:               }
302:           
303:           /******************************************************************************
304:           *   Application Code here! (All tests passed!)
305:           ******************************************************************************/
306:               while(1)
307:               {
308:                   NOP();
00A4  0000     NOP
00A5  28A4     GOTO 0xA4
309:               }
310:           
311:           }
312:           
313:           void ErrorMode (void)
314:           {
315:           /******************************************************************************
316:           *   Put the device into a safe state here!
317:           ******************************************************************************/
318:               INTCON = 0;
00A6  018B     CLRF INTCON
319:               LATB = 0;
00A7  0022     MOVLB 0x2
00A8  018D     CLRF PORTB
320:               LATC = 0;
00A9  018E     CLRF PORTC
321:               LATD = 0;
00AA  018F     CLRF PORTD
322:               LATE = 0xF;
00AB  300F     MOVLW 0xF
00AC  0090     MOVWF PORTE
323:               while(1);
00AD  28AD     GOTO 0xAD
324:           }
0000  3180     MOVLP 0x0
---  C:/Program Files (x86)/Microchip/xc8/v1.12/sources/memcpy.c  ---------------------------------------
1:             #include	<string.h>
2:             #if defined(__18CXX)
3:             #include	<htc.h>
4:             #endif
5:             
6:             #ifdef _PIC16
7:             far void *
8:             memcpy(far void * d1, const void * s1, register size_t n)
9:             #else /*  _PIC16 */
10:            void *
11:            memcpy(void * d1, const void * s1, register size_t n)
12:            #endif /* _PIC16 */
13:            {
14:            
15:            #ifdef _PIC16
16:            	register far char *	d;
17:            #else  /* _PIC16 */
18:            	register char *		d;
19:            #endif /* _PIC16 */
20:            	register const char *	s;
21:            #if defined(__18CXX)
22:            	volatile unsigned short long tmp = TBLPTR;
23:            #endif
24:            	s = s1;
024D  082A     MOVF crcSeed, W
25:            	d = d1;
0251  0828     MOVF length, W
0252  00AF     MOVWF dataSequence
0253  0827     MOVF d1, W
0254  00AE     MOVWF d
26:            	while(n--)
0255  3001     MOVLW 0x1
0256  02AB     SUBWF n, F
0257  3000     MOVLW 0x0
0258  3BAC     SUBWFB 0x2C, F
0259  0A2B     INCF n, W
025A  1903     BTFSC STATUS, 0x2
025B  0A2C     INCF 0x2C, W
025C  1903     BTFSC STATUS, 0x2
025D  0008     RETURN
0270  2A55     GOTO 0x255
27:            		*d++ = *s++;
025E  0830     MOVF s, W
025F  0086     MOVWF FSR1L
0260  0831     MOVF i, W
0261  0087     MOVWF FSR1H
0262  0801     MOVF INDF1, W
0263  00AD     MOVWF dataSequence
0264  082E     MOVF d, W
0265  0086     MOVWF FSR1L
0266  082F     MOVF dataSequence, W
0267  0087     MOVWF FSR1H
0268  082D     MOVF dataSequence, W
0269  0081     MOVWF INDF1
026A  0AB0     INCF s, F
026B  1903     BTFSC STATUS, 0x2
026C  0AB1     INCF i, F
026D  0AAE     INCF d, F
026E  1903     BTFSC STATUS, 0x2
026F  0AAF     INCF dataSequence, F
28:            #if defined(__18CXX)
29:            	TBLPTR = tmp;
30:            #endif
31:            	return d1;
32:            }
0271  3078     MOVLW 0x78
